###############################################################
#                                                             #
#                         ObsidianHub                         #
#                                                             #
# (C)2026 Marc Schöndorf                                      #
#                                                             #
# Smart home dashboard with environmental sensors,            #
# OLED display, RGB LEDs and rotary encoder.                  #
#                                                             #
###############################################################

# ToDo:
# - Do not lock up on ota update error. Show reboot button
# - Rising/falling trends
# - Timer
# - Brightness sync on boot fix
# - Graph range and grid
# - Graph show min max values
# - Use new wifi ap enabled check for determining if in ap mode: https://github.com/esphome/esphome/pull/11852

# Notification:
# Check ignore interactions on notification page!
# Auto font size (bigger font if short message)

###############################################################
# Substitutions
###############################################################
substitutions:
  # ----------------------------------
  # Firmware Version
  version: "1.1.1"

  # ----------------------------------
  # Custom build configuration for clients/users
  client_00pg: false # Enable build for client_00pg

  # ----------------------------------
  # Fallback timezone
  fallback_timezone: "Europe/Berlin"

  # ----------------------------------
  # Weather
  fallback_latitude: "52.5174"   # Fallback location if it cant be automatically determined by IP
  fallback_longitude: "13.3951"  # defaults to Berlin/Germany
  openweathermap_api_key: !secret openweathermap_api_key # API Key for OpenWeatherMap

  # ----------------------------------
  # API Key for HomeAssistant
  api_encryption_key: "D+3rDqdndec4DruSWl6ljJ38cthDGbzFVii186YY66A="

  # ----------------------------------
  # Firmware Update URL
  url_update_manifest_main: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/update/main/manifest.json"
  url_update_manifest_client_00pg: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/update/client_00pg/manifest.json"

  url_update_manifest: ${url_update_manifest_client_00pg if client_00pg else url_update_manifest_main}

  # ----------------------------------
  # Dashboards
  num_dashboard_pages: 4
  enable_system_monitor_dashboard: ${false if ${client_00pg} else true}

###############################################################
# Dashboard Import for easy ESPHome Device Builder usage
###############################################################
dashboard_import:
  package_import_url: github://LostInCompilation/ObsidianHub/Software/ESPHome/obsidianhub.yaml@main
  import_full_config: false

###############################################################
# Device Configuration
###############################################################
esphome:
  name: obsidianhub
  friendly_name: ObsidianHub
  comment: "SmartHome Dashboard with multiple environmental sensors"
  min_version: 2025.12.0
  project:
    name: "Marc.ObsidianHub"
    version: "${version}"
  platformio_options:
    board_build.f_flash: 80000000L
    board_build.flash_mode: qio
  includes:
    - TzDbLookup/tz_data.h
    - TzDbLookup/TzDbLookup.h
    - TzDbLookup/TzDbLookup.cpp
  on_boot:
    priority: -100
    then:
      - script.execute: restore_led_states
      - script.execute: update_graph_durations
      - lambda: |-
          id(main_display).set_contrast(0.0f);
          id(main_display).update();

esp32:
  variant: ESP32C3
  board: esp32-c3-devkitm-1
  cpu_frequency: 160MHz
  framework:
    type: esp-idf
    advanced:
      loop_task_stack_size: 16384

###############################################################
# Flash Memory Writing
###############################################################
preferences:
  flash_write_interval: 30min

###############################################################
# Logging
###############################################################
logger:
  id: component_logger
  level: INFO
  logs:
    wifi: WARN
    api: WARN

#debug:
#  update_interval: 10s

###############################################################
# Home Assistant Integration
# NOTE: Automatic reboots will occur if no API connection
# could be established within 15min (for example if using
# MQTT only without native API). Uncomment reboot_timeout
# to prevent automatic reboots when not using HomeAssostanr
# connection.
###############################################################
api:
  id: component_api
  batch_delay: 200ms
  #reboot_timeout: 0s
  encryption:
    key: "${api_encryption_key}"

  # Debug
  # on_client_connected:
  #   then:
  #     - delay: 500ms
  #     - lambda: |-
  #         ESP_LOGI("brightness", "HA connected — performing brightness sync");

  #         id(brightness_sync_boot).call();

  #         if (!id(brightness_sync_boot).has_state() || std::isnan(id(brightness_sync_boot).state) || id(brightness_sync_boot).state > 255 || id(brightness_sync_boot).state < 0)
  #         {
  #           ESP_LOGW("brightness", "brightness_sync_boot.state is invalid. Ignoring sync in on_client_connected");
  #           return;
  #         }

  #         float tmp = (id(brightness_sync_boot).state / 255.0f) * 100.0f;
  #         uint32_t pct = clamp((int)lround(tmp), 0, 100);

  #         ESP_LOGI("brightness", "Sync brightness = %d%%", pct);

  #         id(brightness_control).publish_state(pct);

###############################################################
# HTTP Requests
###############################################################
http_request:
  id: component_http_request
  follow_redirects: true
  redirect_limit: 3
  buffer_size_rx: 2048
  buffer_size_tx: 512
  timeout: 3s
  watchdog_timeout: 4s
  useragent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"

###############################################################
# Over-The-Air Firmware Updates
###############################################################
ota:
  # HTTP Updates (managed)
  - platform: http_request
    id: component_ota_http
    on_begin:
      then:
        - lambda: |-
            id(return_to_last_saved_page_with_delay).stop();

            id(ota_progress) = 0.0f;
            id(is_menu_detail_visible) = false;
            id(is_menu_visible) = false;
            id(main_display).show_page(id(page_is_updating));
            id(wake_display_and_reset_timer).execute();
    on_progress:
      then:
        - lambda: |-
            id(ota_progress) = x;
            id(main_display).update();
    on_end:
      then:
        - lambda: |-
            id(ota_progress) = 100.0f;
            id(main_display).update();

            delay(1000);
            id(main_display).show_page(page_is_restarting);
            id(main_display).update();
            delay(2000);
            id(main_display).clear();
            id(main_display).update();
    on_error:
      then:
        - lambda: |-
            id(ota_progress) = -1.0f;
            id(main_display).update();

  # ESPHome API
  - platform: esphome
    id: component_ota
    password: "ObsidianHubOTA2025"
    on_begin:
      then:
        - lambda: |-
            id(return_to_last_saved_page_with_delay).stop();

            id(ota_progress) = 0.0f;
            id(is_menu_detail_visible) = false;
            id(is_menu_visible) = false;
            id(main_display).show_page(id(page_is_updating));
            id(wake_display_and_reset_timer).execute();
    on_progress:
      then:
        - lambda: |-
            id(ota_progress) = x;
            id(main_display).update();
    on_end:
      then:
        - lambda: |-
            id(ota_progress) = 100.0f;
            id(main_display).update();

            delay(1000);
            id(main_display).show_page(page_is_restarting);
            id(main_display).update();
            delay(2000);
            id(main_display).clear();
            id(main_display).update();
    on_error:
      then:
        - lambda: |-
            id(ota_progress) = -1.0f;
            id(main_display).update();

# Update component
update:
  - platform: http_request
    name: "Firmware Update"
    id: component_update_firmware_http
    source: "${url_update_manifest}"
    update_interval: 120min
    device_class: "firmware"
    entity_category: "config"
    on_update_available:
      then:
        - script.execute: show_update_available

###############################################################
# WiFi Configuration
###############################################################
wifi:
  # We use WiFi setup over captive portal, so no credentials needed
  #ssid: !secret wifi_ssid
  #password: !secret wifi_password

  id: component_wifi
  enable_btm: true
  enable_rrm: true
  #power_save_mode: none

  on_connect:
    then:
      - lambda: |-
          // Show dashboard and set status LED to green on first WiFi connect after successful setup
          if (!id(wifi_has_been_setup_by_user) || id(main_display).get_active_page() == id(page_wifi_ap_mode))
          {
            id(is_menu_detail_visible) = false;
            id(is_menu_visible) = false;

            id(main_display).show_page(id(page_main_dashboard));
            id(wake_display_and_reset_timer).execute();

            auto call = id(led_status).turn_on();
            call.set_effect("None");
            call.set_rgb(0.0f, 1.0f, 0.0f);
            call.set_brightness(0.8f);
            call.perform();
          }

          id(wifi_has_been_setup_by_user) = true;
  on_disconnect:
    then:
      - lambda: |-
          id(wake_display_and_reset_timer).execute();

  # Fallback access point for initial setup or connection failures
  ap:
    ssid: "ObsidianHub-AP"
    password: "ObsidianHub2025"
    ap_timeout: 60s

# Captive Portal for WiFi Setup
captive_portal:

# Improv over serial as backup WiFi setup method
#improv_serial:

###############################################################
# MQTT Configuration
###############################################################
mqtt:
  broker: !secret mqtt_broker
  port: !secret mqtt_port
  username: !secret mqtt_user
  password: !secret mqtt_password

  log_topic: null
  keepalive: 10s
  publish_nan_as_none: true
  id: mqtt_component
  client_id: obsidianhub
  reboot_timeout: 0s
  idf_send_async: true
  discovery: false    # HA automatic entity discovery
  discover_ip: false  # HA automatic device discovery

###############################################################
# Time Synchronization
# Syncs time from NTP pool servers
###############################################################
time:
  - platform: sntp
    id: sntp_time
    update_interval: 6h
    timezone: "${fallback_timezone}"
    servers:
     - 0.pool.ntp.org
     - 1.pool.ntp.org
     - 2.pool.ntp.org

###############################################################
# Web Server (Optional)
# Uncomment to enable web-based configuration interface
###############################################################
#web_server:
#  version: 3
#  port: 80
#  auth:
#    username: ObsidianHub
#    password: ObsidianHubServer

###############################################################
# I2C Bus Configuration
# Connected sensors: AHT20 (temp/humidity), BMP280 (pressure), BH1750 (light)
###############################################################
i2c:
  id: i2c_bus
  sda:
    number: GPIO9
    ignore_strapping_warning: true
  scl:
    number: GPIO8
    ignore_strapping_warning: true
  scan: false
  frequency: 400kHz
  timeout: 1ms

###############################################################
# SPI Bus Configuration
# Connected sensor: ENS160 (air quality)
###############################################################
spi:
  id: spi_bus
  clk_pin: GPIO4
  mosi_pin: GPIO0
  miso_pin: GPIO1

###############################################################
# Global Variables
###############################################################
globals:
  # --- OTA Progress ---
  - id: ota_progress
    type: float
    restore_value: no
    initial_value: "0.0f"

  # --- Initial WiFi setup done ---
  - id: wifi_has_been_setup_by_user
    type: bool
    restore_value: yes
    initial_value: "false"

  # --- Boot Animation Control ---
  - id: is_boot_complete
    type: bool
    restore_value: no
    initial_value: "false"

  # --- Display Brightness ---
  - id: display_brightness # todo remove, user number directly?
    type: float
    restore_value: yes
    initial_value: "1.0f"

  # --- Spinner Rendering ---
  - id: show_time_sync_spinner
    type: bool
    restore_value: no
    initial_value: "true"

  - id: ens160_sensor_ready
    type: bool
    restore_value: no
    initial_value: "false"

  # --- Sleep/Wake Management ---
  - id: sleep_timeout_milliseconds # todo remove, user number directly?
    type: uint32_t
    restore_value: yes
    initial_value: "30000"

  - id: is_display_sleeping
    type: bool
    restore_value: no
    initial_value: "false"

  - id: is_led_sleeping
    type: bool
    restore_value: no
    initial_value: "false"

  - id: last_interaction_time_ms
    type: uint32_t
    restore_value: no
    initial_value: "0"

  - id: is_fade_out_in_progress
    type: bool
    restore_value: no
    initial_value: "false"

  - id: ignore_next_encoder_button_press_after_wake_up
    type: bool
    restore_value: no
    initial_value: "false"

  # --- Graph Configuration ---
  - id: graph_duration_minutes # todo remove, user number directly?
    type: uint32_t
    restore_value: yes
    initial_value: "30"

  # --- Page Navigation ---
  - id: current_dashboard_page
    type: uint8_t
    restore_value: no
    initial_value: "0"  # 0 = Main dashboard, 1 = Air quality dashboard, 2 = Weather dashboard, 3 = System monitor

  - id: last_saved_page
    type: esphome::display::DisplayPage*
    restore_value: no
    initial_value: "nullptr"

  - id: is_menu_visible
    type: bool
    restore_value: no
    initial_value: "false"

  - id: is_menu_detail_visible
    type: bool
    restore_value: no
    initial_value: "false"

  # --- Selected Button on Update Available Page ---
  - id: update_available_page_selected_button
    type: uint8_t
    restore_value: no
    initial_value: "0"  # 0 = Install, 1 = Later

  # --- PC Monitor Connection Tracking ---
  - id: system_monitor_mqtt_last_update
    type: uint32_t
    restore_value: no
    initial_value: "0"

  # --- Location Fetching For Weather ---
  - id: latitude
    type: float
    restore_value: yes
    initial_value: "${fallback_latitude}"
  - id: longitude
    type: float
    restore_value: yes
    initial_value: "${fallback_longitude}"
  - id: location_fetched
    type: bool
    restore_value: no
    initial_value: "false"

  # --- Parsed Weather JSON ---
  - id: weather_json_doc
    type: JsonDocument
    restore_value: no

  # --- LED State Persistence (survives reboot) ---
  # Format: [brightness, red, green, blue, is_on] for each LED
  - id: saved_status_led_state
    type: float[5]
    restore_value: yes
    initial_value: "{1.0f, 1.0f, 1.0f, 1.0f, 1.0f}"

  - id: saved_key1_led_state
    type: float[5]
    restore_value: yes
    initial_value: "{1.0f, 1.0f, 1.0f, 1.0f, 1.0f}"

  - id: saved_key2_led_state
    type: float[5]
    restore_value: yes
    initial_value: "{1.0f, 1.0f, 1.0f, 1.0f, 1.0f}"

  # --- Custom Notification System ---
  - id: notification_title
    type: std::string
    restore_value: no
    initial_value: '""'

  - id: notification_message
    type: std::string
    restore_value: no
    initial_value: '""'

  - id: notification_timeout
    type: uint32_t
    restore_value: no
    initial_value: "0"

  - id: notification_start_time
    type: uint32_t
    restore_value: no
    initial_value: "0"

  - id: notification_show_border
    type: bool
    restore_value: no
    initial_value: "true"

  - id: notification_button_text
    type: std::string
    restore_value: no
    initial_value: '""'

  - id: notification_needs_scroll_reset
    type: bool
    restore_value: no
    initial_value: "false"

###############################################################
# Fonts
###############################################################
font:
  # --- Digital Clock Display ---
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/fonts/advanced_dot_digital.ttf"
    id: font_clock_large
    size: 20
    glyphs: "0123456789:"

  # --- Air Quality Dashboard ---
  - file:
      type: gfonts
      family: Roboto
      weight: 700
    id: font_aqi_number
    size: 33
    glyphs: "12345"

  - file:
      type: gfonts
      family: IBM Plex Sans
      weight: 700
    id: font_aqi_text_big
    size: 20
    glyphs: "GODPR-"

  - file:
      type: gfonts
      family: IBM Plex Sans
      weight: 700
    id: font_aqi_text_small
    size: 12
    glyphs: "EXCLNTMODRAUHY"

  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/fonts/bdf/9x15.bdf"
    id: font_eco2_tvoc_values
    glyphs: "0123456789pmb"

  # --- Weather Dashboard ---
  - file:
      type: gfonts
      family: IBM Plex Sans
      weight: 700
    id: font_weather_temp
    size: 28
    glyphs: "-°C0123456789"

  # --- Diverse Elements ---
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/fonts/bdf/7x13.bdf"
    id: font7x13
    glyphs: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ .:0123456789\u0025"

  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/fonts/bdf/7x13B.bdf"
    id: font7x13B
    glyphs: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ .0123456789"

  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/fonts/bdf/6x12.bdf"
    id: font6x12
    # Use all glyphs since this font is used for custom notification text
    # ToDo
    #glyphs: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ .:°/|-0123456789\u0025"

  # --- Headers ---
  - file:
      type: gfonts
      family: IBM Plex Sans
      weight: 550
    id: font_ui_18_bold
    size: 18
    glyphs: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ."

  # --- Sub-Header, Menu, Temp & Humid Values ---
  - file:
      type: gfonts
      family: IBM Plex Sans
      weight: 650
    id: font_ui_15_bold
    size: 15
    glyphs: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ .,:'´`!?°#+*=&$§\"<>()/|\\-_0123456789\u0025"

  # --- Large Numbers ---
  - file:
      type: gfonts
      family: Roboto
      weight: 800
    id: font_number_large
    size: 37
    glyphs: "0123456789shm \u0025"

  # --- Big Font ---
  - file:
      type: gfonts
      family: Roboto
      weight: 600
    id: font_ui_21_bold
    size: 21
    glyphs: "ObsidanHuNo WF"

###############################################################
# Images and Icons
###############################################################
image:
  # --- Main Dashboard Icons ---
  - file: mdi:thermometer
    id: icon_temperature
    type: binary
    resize: 24x24

  - file: mdi:water-percent
    id: icon_humidity
    type: binary
    resize: 24x24

  # --- Air Qualiy Dashboard Icons ---
  - file: mdi:leaf
    id: icon_leaf
    type: binary
    resize: 31x31

  - file: mdi:molecule-co2
    id: icon_co2
    type: binary
    resize: 30x26

  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/cloud_icon.png"
    id: icon_cloud
    type: binary
    invert_alpha: false
    resize: 58x11

  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/tvoc_icon.png"
    id: icon_tvoc
    type: binary
    invert_alpha: false

  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/warning.png"
    id: icon_warning
    type: binary
    invert_alpha: true

  # --- System Monitor Icons ---
  - file: mdi:web
    id: icon_web
    type: binary
    resize: 19x19

  - file: mdi:harddisk
    id: icon_hdd
    type: binary
    resize: 19x19

  # --- Menu Icons ---
  - file: mdi:cog
    id: icon_gear
    type: binary
    resize: 22x22

  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/wifi.png"
    id: icon_wifi
    type: binary
    resize: 20x18
    invert_alpha: true

  # --- No WiFi Icon ---
  - file: mdi:wifi-off
    id: icon_wifi_off
    type: binary
    resize: 32x32

  # --- Reboot Confirmation Page Icon ---
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/info.png"
    id: icon_info_big
    type: binary
    invert_alpha: false

  # --- Copyright Text (About page) ---
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/copyright.png"
    id: icon_copyright
    type: binary
    invert_alpha: false

  # --- Weather Icons ---
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/weather/01d.png"
    id: icon_weather_01d
    type: binary
    invert_alpha: false
    resize: 46x46
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/weather/01n.png"
    id: icon_weather_01n
    type: binary
    invert_alpha: false
    resize: 42x46
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/weather/02d.png"
    id: icon_weather_02d
    type: binary
    invert_alpha: false
    resize: 55x55
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/weather/02n.png"
    id: icon_weather_02n
    type: binary
    invert_alpha: false
    resize: 56x56
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/weather/03.png"
    id: icon_weather_03
    type: binary
    invert_alpha: false
    resize: 52x52
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/weather/09.png"
    id: icon_weather_09
    type: binary
    invert_alpha: false
    resize: 50x50
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/weather/10d.png"
    id: icon_weather_10d
    type: binary
    invert_alpha: false
    resize: 50x50
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/weather/10n.png"
    id: icon_weather_10n
    type: binary
    invert_alpha: false
    resize: 50x50
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/weather/11.png"
    id: icon_weather_11
    type: binary
    invert_alpha: false
    resize: 50x50
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/weather/13.png"
    id: icon_weather_13
    type: binary
    invert_alpha: false
    resize: 52x52
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/weather/50.png"
    id: icon_weather_50
    type: binary
    invert_alpha: false
    resize: 52x52
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/weather/1232n.png"
    id: icon_weather_1232n
    type: binary
    invert_alpha: false
    resize: 47x47

###############################################################
# Animations
###############################################################
animation:
  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/boot_animation.gif"
    id: animation_boot
    type: binary
    invert_alpha: false

  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/spinner1.gif"
    id: animation_spinner1
    type: binary
    invert_alpha: true
    resize: 35x35

  - file: "https://github.com/LostInCompilation/ObsidianHub/raw/main/Software/ESPHome/img/spinner2.gif"
    id: animation_spinner2
    type: binary
    invert_alpha: false
    resize: 35x35

###############################################################
# QR Code
###############################################################
qr_code:
  - id: wifi_ap_qr_code
    value: "WIFI:T:WPA;S:ObsidianHub-AP;P:ObsidianHub2025;H:false;;"
    ecc: MEDIUM

###############################################################
# Scripts
###############################################################
script:
  # Wake display and LEDs from sleep, reset inactivity timer
  - id: wake_display_and_reset_timer
    then:
      - lambda: |-
          id(last_interaction_time_ms) = millis();

          // Always set current brightness (needed for auto dim)
          id(main_display).set_contrast(id(display_brightness));

          // Only wake if currently sleeping or fading out
          if (!id(is_display_sleeping) && !id(is_led_sleeping) && !id(is_fade_out_in_progress))
            return;

          id(restore_led_states).execute();

          // Resume display updates and restore brightness
          id(main_display).start_poller();
          id(main_display).update();
          id(main_display).set_contrast(id(display_brightness));

          id(is_display_sleeping) = false;
          id(is_led_sleeping) = false;
          id(is_fade_out_in_progress) = false;

  # Show menu on long press of rotary encoder (wait 600ms and read button again)
  - id: check_for_long_press
    then:
      - delay: 600ms
      - lambda: |-
          // Ignore long press on certain pages
          if(id(main_display).get_active_page() == id(page_graph_duration_restart_confirm)
              || id(main_display).get_active_page() == id(page_is_restarting)
              || id(main_display).get_active_page() == id(page_wifi_ap_mode)
              || id(main_display).get_active_page() == id(page_is_updating)
              || id(main_display).get_active_page() == id(page_update_available)
              || id(main_display).get_active_page() == id(page_notification)
              || id(is_menu_visible)
              || id(is_menu_detail_visible))
            return;

          // Open menu at root item if still pressed
          if (id(button_encoder).state)
          {
            id(return_to_last_saved_page_with_delay).stop();

            // Select root item and only set menu active for processing user actions
            id(main_menu).show_main();
            id(main_menu).hide();
            id(main_menu).set_active(true);

            id(is_menu_visible) = true;
            id(is_menu_detail_visible) = false;
            id(main_display).show_page(id(page_menu));
          }

  # Return to active dashboard page immediately
  - id: return_to_current_dashboard
    then:
      - lambda: |-
          if (id(current_dashboard_page) == 0)
            id(main_display).show_page(id(page_main_dashboard));
          else if (id(current_dashboard_page) == 1)
            id(main_display).show_page(id(page_air_quality));
          else if (id(current_dashboard_page) == 2)
            id(main_display).show_page(id(page_weather_dashboard));
          else if (id(current_dashboard_page) == 3)
            id(main_display).show_page(id(page_system_monitor));

  # Return to last saved page (global variable) after delay.
  # Used for switching back from brightness page
  - id: return_to_last_saved_page_with_delay
    then:
      - delay: 3s
      - lambda: |-
          if (id(last_saved_page) != nullptr)
            id(main_display).show_page(id(last_saved_page));

          id(wake_display_and_reset_timer).execute();

  # Show update available page & LED
  - id: show_update_available
    then:
      - lambda: |-
          if (id(is_boot_complete) && id(main_display).get_active_page() != id(page_update_available))
          {
            id(return_to_last_saved_page_with_delay).stop();

            id(is_menu_detail_visible) = false;
            id(is_menu_visible) = false;

            // Show update available page
            id(main_display).show_page(id(page_update_available));
            id(wake_display_and_reset_timer).execute();

            // Status LEDs
            auto call = id(led_status).turn_on();
            call.set_effect("Turquoise Pulse");
            call.set_rgb(0.0f, 1.0f, 0.85f);
            call.set_brightness(0.8f);
            call.perform();
          }

  # Show custom notification (received via MQTT)
  - id: show_notification
    parameters:
      title: string
      message: string
      timeout: uint32_t
      show_border: bool
      button_text: string
    then:
      - lambda: |-
          id(return_to_last_saved_page_with_delay).stop();

          id(notification_title) = title;
          id(notification_message) = message;
          id(notification_timeout) = timeout;
          id(notification_show_border) = show_border;
          id(notification_button_text) = button_text;
          id(notification_start_time) = millis();
          id(notification_needs_scroll_reset) = true;

          id(is_menu_detail_visible) = false;
          id(is_menu_visible) = false;

          // Reset status LED if on update available page
          if (id(main_display).get_active_page() == id(page_update_available))
          {
            // Turn off turqoise blink effect
            auto call = id(led_status).make_call();
            call.set_effect("None");
            call.perform();
          }

          // Show notification page
          id(main_display).show_page(id(page_notification));
          id(wake_display_and_reset_timer).execute();
          id(restore_led_states).execute();

  # Update all graph durations and grid spacing
  - id: update_graph_durations
    then:
      - lambda: |-
          const uint32_t duration_seconds = id(graph_duration_minutes) * 60;
          uint32_t grid_spacing_sec = 0;

          if (id(graph_duration_minutes) <= 5)
            grid_spacing_sec = 60;
          else if (id(graph_duration_minutes) <= 10)
            grid_spacing_sec = 120;
          else if (id(graph_duration_minutes) <= 50)
            grid_spacing_sec = 600;
          else if (id(graph_duration_minutes) <= 300)
            grid_spacing_sec = 3600;
          else if (id(graph_duration_minutes) <= 720)
            grid_spacing_sec = 7200;
          else
            grid_spacing_sec = 14400;

          // Update all graphs
          id(graph_temp).set_duration(duration_seconds);
          id(graph_temp).set_grid_x(grid_spacing_sec);
          id(graph_temp).reset_to_construction_state();
          id(graph_temp).setup();

          id(graph_humid).set_duration(duration_seconds);
          id(graph_humid).set_grid_x(grid_spacing_sec);
          id(graph_humid).reset_to_construction_state();
          id(graph_humid).setup();

          id(graph_aqi).set_duration(duration_seconds);
          id(graph_aqi).set_grid_x(grid_spacing_sec);
          id(graph_aqi).reset_to_construction_state();
          id(graph_aqi).setup();

          id(graph_eco2).set_duration(duration_seconds);
          id(graph_eco2).set_grid_x(grid_spacing_sec);
          id(graph_eco2).reset_to_construction_state();
          id(graph_eco2).setup();

          id(graph_tvoc).set_duration(duration_seconds);
          id(graph_tvoc).set_grid_x(grid_spacing_sec);
          id(graph_tvoc).reset_to_construction_state();
          id(graph_tvoc).setup();

  # Restore LED states
  - id: restore_led_states
    then:
      - lambda: |-
          // Restore Status LED
          if (id(main_display).get_active_page() != id(page_update_available))
          {
            if (id(saved_status_led_state)[4] > 0.0f)
            {
              auto call = id(led_status).turn_on();
              call.set_rgb(
                  id(saved_status_led_state)[1],
                  id(saved_status_led_state)[2],
                  id(saved_status_led_state)[3]
              );
              call.set_brightness(id(saved_status_led_state)[0]);
              call.perform();
            }
          }
          else
          {
            // On update available page, restore turquoise blinking
            auto call = id(led_status).turn_on();
            call.set_effect("Turquoise Pulse");
            call.set_rgb(0.0f, 1.0f, 0.85f);
            call.set_brightness(0.8f);
            call.perform();
          }

          // Restore Key 1 LED
          if (id(saved_key1_led_state)[4] > 0.0f)
          {
            auto call = id(led_key1).turn_on();
            call.set_rgb(
                id(saved_key1_led_state)[1],
                id(saved_key1_led_state)[2],
                id(saved_key1_led_state)[3]
            );
            call.set_brightness(id(saved_key1_led_state)[0]);
            call.perform();
          }

          // Restore Key 2 LED
          if (id(saved_key2_led_state)[4] > 0.0f)
          {
            auto call = id(led_key2).turn_on();
            call.set_rgb(
                id(saved_key2_led_state)[1],
                id(saved_key2_led_state)[2],
                id(saved_key2_led_state)[3]
            );
            call.set_brightness(id(saved_key2_led_state)[0]);
            call.perform();
          }

  # Get location & timezone from IP
  - id: fetch_location
    then:
      - http_request.get:
          url: "https://ipinfo.io/json"
          capture_response: true
          max_response_buffer_size: 512
          request_headers:
            Content-Type: application/json
          on_response:
            then:
              - lambda: |-
                  if (response->status_code != 200 || body.length() == 0)
                  {
                    ESP_LOGE("fetch_location", "Could not fetch location. Bad response or empty body. Response status: %d", response->status_code);
                    return;
                  }

                  json::parse_json(body, [](JsonObject root) -> bool {
                    // Get timezone
                    if (root["timezone"].is<const char*>())
                    {
                      // Convert IANA to POSIX using TzDbLookup lib
                      const char* posix_tz = TzDbLookup::getPosix(root["timezone"].as<const char*>());

                      if (posix_tz != nullptr)
                      {
                        // Set system wide timezone
                        setenv("TZ", posix_tz, 1);
                        tzset();
                      }
                      else
                      {
                        ESP_LOGE("fetch_location", "Failed to convert timezone to POSIX");
                      }
                    }
                    else
                    {
                      ESP_LOGE("fetch_location", "Missing timezone in response");
                    }

                    // Get location
                    if (root["loc"].is<const char*>())
                    {
                      std::string loc = root["loc"].as<const char*>();
                      const size_t comma_pos = loc.find(',');

                      if (comma_pos == std::string::npos)
                      {
                        ESP_LOGE("fetch_location", "Invalid loc format");
                        return false;
                      }

                      id(latitude) = std::stof(loc.substr(0, comma_pos));
                      id(longitude) = std::stof(loc.substr(comma_pos + 1));
                    }
                    else
                    {
                      ESP_LOGE("fetch_location", "Missing loc in response");
                      return false;
                    }

                    id(location_fetched) = true;

                    ESP_LOGI("fetch_location", "Location detected: %.4f, %.4f, timezone: %s",
                        id(latitude),
                        id(longitude),
                        root["timezone"].is<const char*>() ? root["timezone"].as<const char*>() : "");

                    return true;
                  });
          on_error:
            then:
              - lambda: |-
                  ESP_LOGE("fetch_location", "Could not fetch location");

  # Fetch Weather Data
  - id: fetch_weather
    then:
      - http_request.get:
          url: !lambda |-
            char url[256];
            snprintf(url, sizeof(url),
                    "https://api.openweathermap.org/data/2.5/weather?lat=%.4f&lon=%.4f&appid=${openweathermap_api_key}&units=metric",
                    id(latitude), id(longitude));
            return std::string(url);
          capture_response: true
          max_response_buffer_size: 2048
          request_headers:
            Content-Type: application/json
          on_response:
            then:
              - lambda: |-
                  if (response->status_code != 200 || body.length() == 0)
                  {
                    ESP_LOGE("fetch_weather", "Could not fetch weather data. Response status: %d", response->status_code);
                    return;
                  }

                  // Clear previous document
                  id(weather_json_doc).clear();

                  // Parse JSON into global
                  DeserializationError error = deserializeJson(id(weather_json_doc), body);

                  if (error)
                    ESP_LOGE("fetch_weather", "JSON parsing failed: %s", error.c_str());
                  else
                    ESP_LOGI("fetch_weather", "Weather data updated successfully");
          on_error:
            then:
              - lambda: |-
                  ESP_LOGE("fetch_weather", "HTTP request failed");

###############################################################
# Intervals (Periodic Tasks)
###############################################################
interval:
  # Update boot animation frames
  - interval: 12ms
    then:
      - if:
          condition:
            lambda: "return !id(is_boot_complete);"
          then:
            - lambda: |-
                static bool animation_done = false;

                if (!animation_done)
                {
                  id(animation_boot).next_frame();

                  // Stop on last frame
                  if (id(animation_boot).get_current_frame() >= id(animation_boot).get_animation_frame_count() - 1)
                    animation_done = true;
                }

  # Update spinner1 animation frames (time syncing)
  - interval: 12ms
    startup_delay: 3s
    then:
      - if:
          condition:
            lambda: "return id(is_boot_complete) && id(show_time_sync_spinner);"
          then:
            - animation.next_frame: animation_spinner1

  # Update spinner2 animation frames (wait for ENS160 sensor)
  - interval: 12ms
    startup_delay: 3s
    then:
      - if:
          condition:
            lambda: "return (id(is_boot_complete) && !id(ens160_sensor_ready));"
          then:
            - animation.next_frame: animation_spinner2

  # Reshow update available page if user pressed "Later"
  - interval: 120min
    startup_delay: 10min
    then:
      - if:
          condition:
            update.is_available: component_update_firmware_http
          then:
            - script.execute: show_update_available

  # Custom notification timeout
  - interval: 1s
    then:
      - if:
          condition:
            lambda: "return (id(main_display).get_active_page() == id(page_notification) && id(notification_timeout) > 0);"
          then:
            - lambda: |-
                const uint32_t elapsed = millis() - id(notification_start_time);

                if (elapsed >= id(notification_timeout) * 1000)
                  id(return_to_current_dashboard).execute();

  # Fetch location quickly at the beginning
  - interval: 12s
    startup_delay: 15s
    then:
      - if:
          condition:
            lambda: "return !id(location_fetched) && id(component_wifi).is_connected() && id(wifi_has_been_setup_by_user);"
          then:
            - lambda: |-
                const uint8_t MAX_RETRIES = 4;
                static uint8_t attempt = 0;

                if (attempt < MAX_RETRIES && !id(location_fetched))
                {
                  // Try to fetch location
                  id(fetch_location).execute();
                  attempt++;
                }
                else if (attempt >= MAX_RETRIES && attempt != 0xFF)
                {
                  ESP_LOGW("fetch_location", "Fetching location failed %d times. Fallback to default location (Berlin, Germany)", MAX_RETRIES);

                  // Prevent printing this message again (end state)
                  attempt = 0xFF;
                }

  # Update Weather Data
  - interval: 15min
    startup_delay: 75s
    then:
      - if:
          condition:
            lambda: "return id(component_wifi).is_connected() && id(wifi_has_been_setup_by_user);"
          then:
            - script.execute: fetch_weather

  # Save current LED states to global which will be written to flash automatically
  - interval: 500ms
    startup_delay: 2s
    then:
      - lambda: |-
          // Don't save while on certain pages
          if (id(main_display).get_active_page() == id(page_is_updating)
              || id(main_display).get_active_page() == id(page_wifi_ap_mode)
              || id(main_display).get_active_page() == id(page_update_available))
            return;

          // Save Status LED state
          auto current = id(led_status).current_values;
          id(saved_status_led_state)[0] = current.get_brightness();
          id(saved_status_led_state)[1] = current.get_red();
          id(saved_status_led_state)[2] = current.get_green();
          id(saved_status_led_state)[3] = current.get_blue();

          // Save Key 1 LED state
          current = id(led_key1).current_values;
          id(saved_key1_led_state)[0] = current.get_brightness();
          id(saved_key1_led_state)[1] = current.get_red();
          id(saved_key1_led_state)[2] = current.get_green();
          id(saved_key1_led_state)[3] = current.get_blue();

          // Save Key 2 LED state
          current = id(led_key2).current_values;
          id(saved_key2_led_state)[0] = current.get_brightness();
          id(saved_key2_led_state)[1] = current.get_red();
          id(saved_key2_led_state)[2] = current.get_green();
          id(saved_key2_led_state)[3] = current.get_blue();

          // Save is_on() state only when not sleeping LEDs
          if (!id(is_fade_out_in_progress) && !id(is_led_sleeping))
          {
            id(saved_status_led_state)[4] = id(led_status).current_values.is_on() ? 1.0f : 0.0f;
            id(saved_key1_led_state)[4] = id(led_key1).current_values.is_on() ? 1.0f : 0.0f;
            id(saved_key2_led_state)[4] = id(led_key2).current_values.is_on() ? 1.0f : 0.0f;
          }

  # Handle WiFi AP mode detection
  # Show WiFi setup page if we loose WiFi connection for at least 1min
  - interval: 10s
    then:
      - lambda: |-
          static uint32_t ap_mode_timer = 0;
          static bool leds_have_been_set = false;

          if (!id(component_wifi).is_connected() && id(is_boot_complete) && id(wifi_has_been_setup_by_user))
          {
            ap_mode_timer++;

            // Trigger after 60s of no WiFi connection
            if (ap_mode_timer > 6)
            {
              id(wake_display_and_reset_timer).execute();
              id(return_to_last_saved_page_with_delay).stop();

              // Show AP page
              id(is_menu_detail_visible) = false;
              id(is_menu_visible) = false;
              id(main_display).show_page(id(page_wifi_ap_mode));

              // Status LEDs
              if (!leds_have_been_set)
              {
                auto call = id(led_status).turn_on();
                call.set_effect("Red Pulse");
                call.set_rgb(1.0f, 0.0f, 0.0f);
                call.set_brightness(0.9f);
                call.perform();

                leds_have_been_set = true;
              }
            }
          }
          else
          {
            ap_mode_timer = 0;
            leds_have_been_set = false;
          }

  # Handle boot animation, auto-sleep and auto dimming of the display
  - interval: 75ms
    then:
      - lambda: |-
          static const uint32_t BOOT_LOGO_HOLD_MS = 4800;
          static const uint32_t FADE_DURATION_MS = 700;
          static const float GAMMA = 2.5f;  // Human eye perception correction
          static const float INV_FADE_DURATION = 1.0f / FADE_DURATION_MS;
          static const uint32_t AUTO_DIM_CHECK_INTERVAL_MS = 5000;
          static const uint32_t AUTO_DIM_DELAY_MS = 5000;

          static uint32_t fade_start = 0;
          static uint32_t hold_start = 0;
          static bool fade_done = false;
          static uint32_t last_auto_dim_check = 0;
          static float auto_dim_target_brightness = -1.0f;
          static float auto_dim_start_brightness = -1.0f;
          static uint32_t auto_dim_fade_start = 0;
          static bool auto_dim_fade_in_progress = false;

          const uint32_t now = millis();

          // ========================================================
          // BOOT SEQUENCE: Fade in logo -> hold -> show dashboard
          // ========================================================
          if (!id(is_boot_complete))
          {
            if (fade_start == 0)
              fade_start = now;

            // Fade in phase
            if (!fade_done)
            {
              const uint32_t elapsed = now - fade_start;
              const float progress = elapsed * INV_FADE_DURATION;
              const float correctedValue = pow(progress, GAMMA);

              if (elapsed < FADE_DURATION_MS && correctedValue < id(display_brightness))
              {
                id(main_display).set_contrast(correctedValue);
              }
              else
              {
                fade_done = true;
                hold_start = now;
                id(main_display).set_contrast(id(display_brightness));
              }
            }
            else if (now - hold_start >= BOOT_LOGO_HOLD_MS) // Hold phase complete
            {
              // Publish initial config values
              id(config_display_brightness).publish_state((int32_t)(id(display_brightness) * 100.0f));
              id(config_auto_sleep).publish_state(id(sleep_timeout_milliseconds) / 1000);

              id(is_boot_complete) = true;
              id(last_interaction_time_ms) = now;

              // Show dashboard or WiFi setup page if it hasn't been set up by user already
              if (id(wifi_has_been_setup_by_user))
              {
                id(main_display).show_page(id(page_main_dashboard));
              }
              else
              {
                id(main_display).show_page(id(page_wifi_ap_mode));

                // Init LEDs for WiFi setup mode
                auto call = id(led_status).turn_on();
                call.set_effect("Blue Pulse");
                call.set_rgb(0.0f, 0.0f, 1.0f);
                call.set_brightness(0.8f);
                call.perform();

                // Key LEDs
                call = id(led_key1).turn_on();
                call.set_rgb(1.0f, 1.0f, 1.0f);
                call.set_brightness(0.7f);
                call.perform();

                call = id(led_key2).turn_on();
                call.set_rgb(1.0f, 1.0f, 1.0f);
                call.set_brightness(0.7f);
                call.perform();
              }
            }
          }
          // ================================================
          // AUTO-SLEEP: Fade out after inactivity timeout
          // ================================================
          // This huge if-statement is necessary (sadly) since we cant use early returns here
          else if (id(sleep_timeout_milliseconds) > 0
                    && (!id(is_display_sleeping) || !id(is_led_sleeping))
                    && id(main_display).get_active_page() != id(page_graph_duration_restart_confirm)
                    && id(main_display).get_active_page() != id(page_is_restarting)
                    && id(main_display).get_active_page() != id(page_wifi_ap_mode)
                    && id(main_display).get_active_page() != id(page_is_updating)
                    && id(main_display).get_active_page() != id(page_notification))
          {
            const bool any_button_held = id(button_encoder).state ||
                                      id(button_left).state ||
                                      id(button_right).state;

            // If any button is held, reset the timer to prevent sleep
            if (any_button_held)
            {
              id(last_interaction_time_ms) = now;

              // Cancel fade out if in progress
              if (id(is_fade_out_in_progress))
              {
                id(is_fade_out_in_progress) = false;
                id(main_display).set_contrast(id(display_brightness));
              }

              return;
            }

            // Sleep components
            const char* sleep_option = id(select_sleep_components).current_option();
            const bool sleep_display = (strcmp(sleep_option, "Both") == 0 || strcmp(sleep_option, "Display") == 0);
            const bool sleep_leds = (strcmp(sleep_option, "Both") == 0 || strcmp(sleep_option, "LEDs") == 0);

            const uint32_t idle_time = now - id(last_interaction_time_ms);
            const bool timeout_reached = (idle_time >= id(sleep_timeout_milliseconds));

            // Display fade out
            if (sleep_display && !id(is_display_sleeping))
            {
              if (timeout_reached && !id(is_fade_out_in_progress))
              {
                id(is_fade_out_in_progress) = true;
                fade_start = now;
              }

              // Perform fade out
              if (id(is_fade_out_in_progress))
              {
                const uint32_t elapsed = now - fade_start;

                if (elapsed < FADE_DURATION_MS)
                {
                  // Fading
                  const float progress = 1.0f - (elapsed * INV_FADE_DURATION);
                  const float gamma_corrected = pow(progress, GAMMA) * id(main_display).get_contrast();
                  id(main_display).set_contrast(gamma_corrected);
                }
                else
                {
                  // Fade complete
                  id(is_fade_out_in_progress) = false;
                  id(main_display).set_contrast(0.0f);
                  id(main_display).stop_poller();
                  id(is_display_sleeping) = true;
                }
              }
            }

            // LEDs
            if (sleep_leds && timeout_reached && !id(is_led_sleeping))
            {
              id(led_status).turn_off().perform();
              id(led_key1).turn_off().perform();
              id(led_key2).turn_off().perform();
              id(is_led_sleeping) = true;
            }
          }

          // =============================================
          // AUTO-DIM: Smooth fade to ambient brightness
          // =============================================
          if (id(is_boot_complete)
              && id(switch_auto_dim_display).state
              && !id(is_display_sleeping)
              && !id(is_fade_out_in_progress)
              && id(sensor_brightness).has_state()
              && id(main_display).get_active_page() != id(page_graph_duration_restart_confirm)
              && id(main_display).get_active_page() != id(page_is_restarting)
              && id(main_display).get_active_page() != id(page_wifi_ap_mode)
              && id(main_display).get_active_page() != id(page_is_updating))
          {
            const uint32_t idle_time = now - id(last_interaction_time_ms);

            // Check if user just interacted - cancel auto-dim and reset state
            if (idle_time < AUTO_DIM_DELAY_MS)
            {
              if (auto_dim_fade_in_progress || auto_dim_target_brightness >= 0.0f)
              {
                auto_dim_fade_in_progress = false;
                auto_dim_target_brightness = -1.0f;
                auto_dim_start_brightness = -1.0f;
                id(main_display).set_contrast(id(display_brightness));
              }
            }

            // Check brightness sensor every AUTO_DIM_CHECK_INTERVAL_MS
            if (now - last_auto_dim_check >= AUTO_DIM_CHECK_INTERVAL_MS)
            {
              last_auto_dim_check = now;

              // Start auto-dim after AUTO_DIM_DELAY_MS of inactivity
              if (idle_time >= AUTO_DIM_DELAY_MS)
              {
                const float env_brightness = id(sensor_brightness).state;
                float new_target = -1.0f;

                if (env_brightness <= 0.5f)
                {
                  // Darkness, dim to low brightness
                  new_target = 0.1f;
                }
                else if (env_brightness <= 2.0f)
                {
                  // Dim a little (half the set brightness)
                  new_target = max(id(display_brightness) / 2.0f, 0.1f);
                }
                else
                {
                  // No dim
                  new_target = id(display_brightness);
                }

                // Only start new fade if target changed
                if (new_target != auto_dim_target_brightness)
                {
                  auto_dim_target_brightness = new_target;
                  auto_dim_start_brightness = id(main_display).get_contrast();
                  auto_dim_fade_start = now;
                  auto_dim_fade_in_progress = true;
                }
              }
            }

            // Perform auto-dim fade
            if (auto_dim_fade_in_progress && auto_dim_target_brightness >= 0.0f)
            {
              const uint32_t elapsed = now - auto_dim_fade_start;

              if (elapsed < FADE_DURATION_MS)
              {
                // Fading
                const float progress = elapsed * INV_FADE_DURATION;
                const float gamma_corrected = pow(progress, GAMMA);
                const float current_brightness = auto_dim_start_brightness +
                                                  (auto_dim_target_brightness - auto_dim_start_brightness) * gamma_corrected;
                id(main_display).set_contrast(current_brightness);
              }
              else
              {
                // Fade complete
                id(main_display).set_contrast(auto_dim_target_brightness);
                auto_dim_fade_in_progress = false;
              }
            }
          }

###############################################################
# OLED Display Configuration
###############################################################
display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    id: main_display
    address: 0x3C
    contrast: 0%  # Start at zero for boot fade-in
    update_interval: 25ms

    # Force immediate redraw when switching pages
    on_page_change:
      then:
        - component.update: main_display

    pages:
      # ============================================
      # BOOT LOGO PAGE
      # ============================================
      - id: page_boot_logo
        lambda: |-
          it.image(20, -6, id(animation_boot));

      # ============================================
      # RESTARTING PAGE
      # ============================================
      - id: page_is_restarting
        lambda: |-
          it.printf(64, 32, id(font_ui_18_bold), TextAlign::CENTER, "Rebooting...");

      # ============================================
      # UPDATE AVAILABLE PAGE
      # ============================================
      - id: page_update_available
        lambda: |-
          it.printf(64, 8, id(font_ui_15_bold), TextAlign::CENTER, "Firmware update");
          it.printf(64, 25, id(font_ui_15_bold), TextAlign::CENTER, "available");

          const uint32_t button_width = 58;
          const uint32_t button_height = 19;
          const uint32_t button_spacing = 8;
          const uint32_t button_y = 43;
          const uint32_t button_text_offset = 3;

          uint32_t install_x = 64 - button_width - (button_spacing / 2);
          uint32_t later_x = 64 + (button_spacing / 2);

          // Install Button
          if (id(update_available_page_selected_button) == 0)
          {
            // Selected - filled
            it.filled_rectangle(install_x, button_y, button_width, button_height);
            it.printf(install_x + (button_width / 2), button_y + button_text_offset, id(font7x13B), COLOR_OFF, TextAlign::TOP_CENTER, "INSTALL");
          }
          else
          {
            // Not selected - outline only
            it.rectangle(install_x, button_y, button_width, button_height);
            it.printf(install_x + (button_width / 2), button_y + button_text_offset, id(font7x13B), TextAlign::TOP_CENTER, "INSTALL");
          }

          // Later button
          if (id(update_available_page_selected_button) == 1)
          {
            // Selected - filled
            it.filled_rectangle(later_x, button_y, button_width, button_height);
            it.printf(later_x + (button_width / 2), button_y + button_text_offset, id(font7x13B), COLOR_OFF, TextAlign::TOP_CENTER, "LATER");
          }
          else
          {
            // Not selected - outline only
            it.rectangle(later_x, button_y, button_width, button_height);
            it.printf(later_x + (button_width / 2), button_y + button_text_offset, id(font7x13B), TextAlign::TOP_CENTER, "LATER");
          }

      # ============================================
      # OTA UPDATING PAGE
      # ============================================
      - id: page_is_updating
        lambda: |-
          it.printf(64, 2, id(font_ui_18_bold), TextAlign::TOP_CENTER, "Updating");

          if (id(ota_progress) < 0)
          {
            // Error state
            it.printf(64, 30, id(font_ui_15_bold), TextAlign::TOP_CENTER, "FAILED!");
            return;
          }

          it.printf(64, 28, id(font_ui_15_bold), TextAlign::TOP_CENTER,
                    "%.0f%%", id(ota_progress));

          // Progress bar
          const uint32_t BAR_W = 100, BAR_H = 10, BAR_X = 14, BAR_Y = 50;
          uint32_t fill_w = (uint32_t)((id(ota_progress) / 100.0f) * (BAR_W - 4));
          it.rectangle(BAR_X, BAR_Y, BAR_W, BAR_H);
          if (fill_w > 0)
            it.filled_rectangle(BAR_X + 2, BAR_Y + 2, fill_w, BAR_H - 4);

      # ============================================
      # WIFI AP PAGE
      # ============================================
      - id: page_wifi_ap_mode
        lambda: |-
          it.printf(28, 24, id(font_ui_15_bold), TextAlign::CENTER, "Setup");
          it.printf(28, 41, id(font_ui_15_bold), TextAlign::CENTER, "WiFi");

          // Draw the QR-code
          it.qr_code(62, 0, id(wifi_ap_qr_code), COLOR_ON, 2);

      # ============================================
      # MAIN DASHBOARD: Clock, Temperature, Humidity
      # ============================================
      - id: page_main_dashboard
        lambda: |-
          static const uint32_t MIN_SPINNER_TIME_MS = 6000;
          static const uint32_t MIN_NO_WIFI_TIME_MS = 1000;
          static uint32_t spinner_start_time = millis();
          static uint32_t wifi_lost_time = 0;

          const uint32_t now = millis();
          const bool wifi_connected = id(component_wifi).is_connected();

          // Check WiFi disconnect
          if (wifi_connected)
            wifi_lost_time = 0;
          else if (wifi_lost_time == 0)
            wifi_lost_time = now;

          const bool show_no_wifi = !wifi_connected && (now - wifi_lost_time >= MIN_NO_WIFI_TIME_MS);

          if (show_no_wifi)
          {
            // Show "No WiFi"
            it.image(5, 5, id(icon_wifi_off));
            it.printf(45, 9, id(font_ui_21_bold), TextAlign::TOP_LEFT, "No WiFi");
          }
          else
          {
            // WiFi connected or in grace period - show spinner/clock
            if (id(sntp_time).now().is_valid())
            {
              if (now - spinner_start_time >= MIN_SPINNER_TIME_MS)
                id(show_time_sync_spinner) = false;
            }
            else
            {
              id(show_time_sync_spinner) = true;
              spinner_start_time = now;
            }

            if (id(show_time_sync_spinner))
            {
              it.image(3, 1, id(animation_spinner1));
              it.printf(46, 6, id(font_ui_18_bold), TextAlign::TOP_LEFT, "Syncing...");
            }
            else
            {
              it.strftime(65, 16, id(font_clock_large), TextAlign::TOP_CENTER,
                          "%H:%M:%S", id(sntp_time).now());
            }
          }

          // Temperature display
          it.image(-2, 40, id(icon_temperature));
          it.printf(19, 41, id(font_ui_15_bold), TextAlign::TOP_LEFT, "%.1f°C", id(sensor_temperature).state);

          // Humidity display
          it.image(70, 40, id(icon_humidity));
          it.printf(92, 41, id(font_ui_15_bold), TextAlign::TOP_LEFT, "%.0f%%", id(sensor_humidity).state);

      # ============================================
      # AIR QUALITY DASHBOARD: AQI, CO2, TVOC
      # ============================================
      - id: page_air_quality
        lambda: |-
          // Check if sensor readings are valid (not NaN)
          id(ens160_sensor_ready) = id(sensor_aqi).has_state() &&
                             id(sensor_eco2).has_state() &&
                             id(sensor_tvoc).has_state() &&
                             !std::isnan(id(sensor_aqi).state) &&
                             !std::isnan(id(sensor_eco2).state) &&
                             !std::isnan(id(sensor_tvoc).state);

          if (!id(ens160_sensor_ready))
          {
            unsigned long uptime_sec = millis() / 1000;
            int32_t minutes_remaining = 3 - (uptime_sec / 60);
            if (minutes_remaining < 1)
              minutes_remaining = 1;

            // Show wait for sensor spinner
            it.image(0, 8, id(animation_spinner2));
            it.printf(40, 26, id(font_ui_18_bold), TextAlign::BOTTOM_LEFT, "Air Quality");
            it.printf(46, 28, id(font7x13), TextAlign::TOP_LEFT, "Preparing...");

            // Show remaining time at the bottom
            it.printf(64, 63, id(font6x12), TextAlign::BOTTOM_CENTER, "%dmin remaining", minutes_remaining);

            return;
          }

          // AQI
          const uint32_t aqi_value = (uint32_t)id(sensor_aqi).state;
          int32_t aqi_number_x_offset = 0;
          int32_t aqi_number_x_gap_extend = 0;

          // Responsive layout
          if (aqi_value == 1)
          {
            aqi_number_x_gap_extend = -1;
          }
          else if (aqi_value == 4)
          {
            aqi_number_x_offset = -3;
            aqi_number_x_gap_extend = 4;
          }
          else if (aqi_value == 5)
          {
            aqi_number_x_offset = -5;
            aqi_number_x_gap_extend = 3;
          }

          // Show icon
          if (aqi_value <= 3)
            it.image(6 + aqi_number_x_offset, -3, id(icon_leaf));
          else
            it.image(6 + aqi_number_x_offset, -3, id(icon_warning));

          // Big AQI number
          it.printf(37 + aqi_number_x_offset + aqi_number_x_gap_extend, -6, id(font_aqi_number), TextAlign::TOP_LEFT, "%d", aqi_value);

          switch (aqi_value)
          {
            case 1:
              it.printf(126, 13, id(font_aqi_text_small), TextAlign::CENTER_RIGHT, "EXCELLENT");
            break;

            case 2:
              it.printf(123, 13, id(font_aqi_text_big), TextAlign::CENTER_RIGHT, "GOOD");
            break;

            case 3:
              it.printf(127, 13, id(font_aqi_text_small), TextAlign::CENTER_RIGHT, "MODERATE");
            break;

            case 4:
              it.printf(123, 13, id(font_aqi_text_big), TextAlign::CENTER_RIGHT, "POOR");
            break;

            case 5:
              it.printf(128, 13, id(font_aqi_text_small), TextAlign::CENTER_RIGHT, "UNHEALTHY");
            break;

            default:
              it.printf(105, 13, id(font_aqi_text_big), TextAlign::CENTER_RIGHT, "---");
            break;
          }

          // ***********************************
          // CO2
          it.image(25, 28, id(icon_co2));
          it.image(8, 36, id(icon_cloud));

          // Get the width of the value text
          uint32_t value_x = 19;
          std::string value_str = str_sprintf("%u", (uint32_t)id(sensor_eco2).state);
          int x1, y1, value_width, value_height;
          it.get_text_bounds(0, 0, value_str.c_str(), id(font_eco2_tvoc_values),
                            TextAlign::BOTTOM_CENTER, &x1, &y1, &value_width, &value_height);

          uint32_t unit_x = value_x + (value_width / 2) + 3;
          it.printf(value_x, 65, id(font_eco2_tvoc_values), TextAlign::BOTTOM_CENTER, "%u", (uint32_t)id(sensor_eco2).state);
          it.print(unit_x, 63, id(font6x12), TextAlign::BOTTOM_LEFT, "ppm");

          // ***********************************
          // TVOC
          it.image(68, 35, id(icon_tvoc));

          // Get the width of the value text
          value_x = 88;
          value_str = str_sprintf("%u", (uint32_t)id(sensor_tvoc).state);
          it.get_text_bounds(0, 0, value_str.c_str(), id(font_eco2_tvoc_values),
                            TextAlign::BOTTOM_CENTER, &x1, &y1, &value_width, &value_height);

          unit_x = value_x + (value_width / 2) + 3;
          it.printf(value_x, 65, id(font_eco2_tvoc_values), TextAlign::BOTTOM_CENTER, "%u", (uint32_t)id(sensor_tvoc).state);
          it.print(unit_x, 63, id(font6x12), TextAlign::BOTTOM_LEFT, "ppb");

      # ============================================
      # SYSTEM MONITOR DASHBOARD
      # ============================================
      - id: page_system_monitor
        lambda: |-
          const bool is_connected = (millis() - id(system_monitor_mqtt_last_update)) < 8000;

          if (!id(mqtt_cpu_percent).has_state() || !is_connected)
          {
            it.printf(64, 2, id(font_ui_18_bold), TextAlign::TOP_CENTER, "SYSTEM STATS");
            it.printf(64, 30, id(font_ui_15_bold), TextAlign::TOP_CENTER, "No Data");
            return;
          }

          // Static variables persist between lambda calls
          static float smooth_cpu = 0.0f;
          static float smooth_ram = 0.0f;

          // Smoothing factor
          const float SMOOTHING = 0.08f;

          // Smooth CPU percentage
          float target_cpu = id(mqtt_cpu_percent).state;
          smooth_cpu += (target_cpu - smooth_cpu) * SMOOTHING;

          // Smooth RAM percentage
          float target_ram = id(mqtt_ram_percent).state;
          smooth_ram += (target_ram - smooth_ram) * SMOOTHING;

          // CPU text (show actual value)
          it.printf(1, -1, id(font7x13B), TextAlign::TOP_LEFT, "CPU");
          it.printf(128, -1, id(font7x13), TextAlign::TOP_RIGHT, "%d%%", lround(target_cpu));

          // RAM text (show actual value)
          it.printf(1, 12, id(font7x13B), TextAlign::TOP_LEFT, "RAM");
          it.printf(128, 12, id(font7x13), TextAlign::TOP_RIGHT, "%d%%", lround(target_ram));

          // Disk
          it.image(5, 25, id(icon_hdd));
          it.printf(39, 24, id(font_ui_15_bold), TextAlign::TOP_CENTER, "Disk");
          it.printf(31, 43, id(font6x12), TextAlign::TOP_CENTER, "W %.1fMB", id(mqtt_disk_write).state);
          it.printf(31, 53, id(font6x12), TextAlign::TOP_CENTER, "R %.1fMB", id(mqtt_disk_read).state);

          // Network
          it.image(75, 25, id(icon_web));
          it.printf(96, 24, id(font_ui_15_bold), TextAlign::TOP_LEFT, "Net");
          it.printf(79, 43, id(font6x12), TextAlign::TOP_LEFT, "U %.1fMb", id(mqtt_net_sent).state * 8.0f);
          it.printf(79, 53, id(font6x12), TextAlign::TOP_LEFT, "D %.1fMb", id(mqtt_net_recv).state * 8.0f);

          // CPU progress bar
          const uint32_t BAR_W = 75;
          const uint32_t BAR_H = 9;
          const uint32_t BAR_X = 26;
          uint32_t BAR_Y = 1;
          uint32_t fill_w = (uint32_t)( (smooth_cpu / 100.0f) * (BAR_W - 4) );
          it.rectangle(BAR_X, BAR_Y, BAR_W, BAR_H);
          if (fill_w > 0)
            it.filled_rectangle(BAR_X + 2, BAR_Y + 2, fill_w, BAR_H - 4);

          // RAM progress bar
          BAR_Y = 14;
          fill_w = (uint32_t)( (smooth_ram / 100.0f) * (BAR_W - 4) );
          it.rectangle(BAR_X, BAR_Y, BAR_W, BAR_H);
          if (fill_w > 0)
            it.filled_rectangle(BAR_X + 2, BAR_Y + 2, fill_w, BAR_H - 4);

      # ============================================
      # WEATHER DASHBOARD
      # ============================================
      - id: page_weather_dashboard
        lambda: |-
          if (id(weather_json_doc).isNull())
          {
            // No weather data yet
            it.printf(64, 12, id(font_ui_15_bold), TextAlign::TOP_CENTER, "Loading Weather");
            it.printf(64, 32, id(font_ui_15_bold), TextAlign::TOP_CENTER, "Data...");
            return;
          }

          static JsonObject root = id(weather_json_doc).as<JsonObject>();

          // =============================================
          // Icon
          int8_t icon_x = 0;
          int8_t icon_y = 0;
          static char icon[8] = "";

          if (root["weather"][0]["icon"].is<const char*>())
          {
            const char* icon_str = root["weather"][0]["icon"].as<const char*>();
            strncpy(icon, icon_str, sizeof(icon) - 1);
            icon[sizeof(icon) - 1] = '\0';
          }

          // Draw weather icon based on OpenWeatherMap icon code
          if (strcmp(icon, "01d") == 0)
          {
            icon_x = 6;
            icon_y = 1;
            it.image(icon_x, icon_y, id(icon_weather_01d));
          }
          else if (strcmp(icon, "01n") == 0)
          {
            icon_x = 10;
            icon_y = 1;
            it.image(icon_x, icon_y, id(icon_weather_01n));
          }
          else if (strcmp(icon, "02d") == 0 || strcmp(icon, "03d") == 0)
          {
            icon_x = 1;
            icon_y = -4;
            it.image(icon_x, icon_y, id(icon_weather_02d));
          }
          else if (strcmp(icon, "02n") == 0 || strcmp(icon, "03n") == 0)
          {
            icon_x = 1;
            icon_y = -5;
            it.image(icon_x, icon_y, id(icon_weather_02n));
          }
          else if (strcmp(icon, "04d") == 0 || strcmp(icon, "04n") == 0)
          {
            icon_x = 3;
            icon_y = -4;
            it.image(icon_x, icon_y, id(icon_weather_03));
          }
          else if (strcmp(icon, "09d") == 0 || strcmp(icon, "09n") == 0)
          {
            icon_x = 3;
            icon_y = 0;
            it.image(icon_x, icon_y, id(icon_weather_09));
          }
          else if (strcmp(icon, "10d") == 0)
          {
            icon_x = 5;
            icon_y = 0;
            it.image(icon_x, icon_y, id(icon_weather_10d));
          }
          else if (strcmp(icon, "10n") == 0)
          {
            icon_x = 5;
            icon_y = 0;
            it.image(icon_x, icon_y, id(icon_weather_10n));
          }
          else if (strcmp(icon, "11d") == 0 || strcmp(icon, "11n") == 0)
          {
            icon_x = 3;
            icon_y = 0;
            it.image(icon_x, icon_y, id(icon_weather_11));
          }
          else if (strcmp(icon, "13d") == 0 || strcmp(icon, "13n") == 0)
          {
            icon_x = 2;
            icon_y = -1;
            it.image(icon_x, icon_y, id(icon_weather_13));
          }
          else if (strcmp(icon, "50d") == 0 || strcmp(icon, "50n") == 0)
          {
            icon_x = 2;
            icon_y = -3;
            it.image(icon_x, icon_y, id(icon_weather_50));
          }
          else if (strcmp(icon, "1232n") == 0)
          {
            icon_x = 4;
            icon_y = -1;
            it.image(icon_x, icon_y, id(icon_weather_1232n));
          }

          // =============================================
          // Description
          if (root["weather"][0]["main"].is<const char*>())
            it.printf(94, 1, id(font6x12), TextAlign::TOP_CENTER, "%s", root["weather"][0]["main"].as<const char*>());

          // =============================================
          // Temperature
          if (root["main"]["temp"].is<float>())
            it.printf(94, 9, id(font_weather_temp), TextAlign::TOP_CENTER, "%d°C", lround(root["main"]["temp"].as<float>()));

          // =============================================
          // TICKER
          // =============================================
          const int32_t SCROLL_INTERVAL = 45;
          const int32_t SCROLL_STEP = 1;
          const int32_t TICKER_Y = 63;
          const char* SEPARATOR = "  |  ";

          static int32_t ticker_offset = 126; // Start position
          static int32_t ticker_width = 0;
          static int32_t last_scroll_time = 0;
          static char ticker_text[372] = "";

          // For building new ticker text
          char new_ticker[256] = "";
          char temp_buf[32];
          int32_t pos = 0;

          // City
          if (root["name"].is<const char*>())
          {
            pos += snprintf(new_ticker + pos, sizeof(new_ticker) - pos,
                            "%s%s", (pos > 0 ? SEPARATOR : ""),
                            root["name"].as<const char*>());
          }

          // Min Temperature
          if (root["main"]["temp_min"].is<float>())
          {
            pos += snprintf(new_ticker + pos, sizeof(new_ticker) - pos,
                            "%sLow: %d°C", (pos > 0 ? SEPARATOR : ""),
                            lround(root["main"]["temp_min"].as<float>()));
          }

          // Max Temperature
          if (root["main"]["temp_max"].is<float>())
          {
            pos += snprintf(new_ticker + pos, sizeof(new_ticker) - pos,
                            "%sHigh: %d°C", (pos > 0 ? SEPARATOR : ""),
                            lround(root["main"]["temp_max"].as<float>()));
          }

          // Humidity
          if (root["main"]["humidity"].is<uint8_t>())
          {
            pos += snprintf(new_ticker + pos, sizeof(new_ticker) - pos,
                            "%sHumid: %u%%", (pos > 0 ? SEPARATOR : ""),
                            root["main"]["humidity"].as<uint8_t>());
          }

          // Wind Speed
          if (root["wind"]["speed"].is<float>())
          {
            const float wind_kmh = root["wind"]["speed"].as<float>() * 3.6f;
            pos += snprintf(new_ticker + pos, sizeof(new_ticker) - pos,
                            "%sWind: %dkm/h", (pos > 0 ? SEPARATOR : ""),
                            lround(wind_kmh));
          }

          // Add padding at the end
          snprintf(new_ticker + pos, sizeof(new_ticker) - pos, "         ");

          // Update ticker if text changed
          if (strcmp(new_ticker, ticker_text) != 0)
          {
            strcpy(ticker_text, new_ticker);

            int bx, by, bw, bh;
            it.get_text_bounds(0, 0, ticker_text, id(font6x12),
                              TextAlign::BOTTOM_LEFT, &bx, &by, &bw, &bh);

            ticker_width = bw;
          }

          // Update scroll position
          uint32_t current_time = millis();
          if (current_time - last_scroll_time >= SCROLL_INTERVAL)
          {
            ticker_offset -= SCROLL_STEP;
            last_scroll_time = current_time;

            // Reset position for looping
            if (ticker_offset <= -ticker_width)
              ticker_offset = 0;
          }

          // Draw ticker (both copies for endless scrolling)
          it.print(ticker_offset, TICKER_Y, id(font6x12), TextAlign::BOTTOM_LEFT, ticker_text);
          it.print(ticker_offset + ticker_width, TICKER_Y, id(font6x12), TextAlign::BOTTOM_LEFT, ticker_text);

      # ============================================
      # BRIGHTNESS CONTROL: Shows percentage with progress bar
      # ============================================
      - id: page_brightness_control
        lambda: |-
          // Header
          it.printf(64, 1, id(font7x13B), TextAlign::TOP_CENTER, "BRIGHTNESS");

          // Large percentage value
          it.printf(64, 11, id(font_number_large), TextAlign::TOP_CENTER, "%.0f%%", id(brightness_control).state);

          // Progress bar
          const uint32_t BAR_W = 100, BAR_H = 10, BAR_X = 14, BAR_Y = 54;
          it.rectangle(BAR_X, BAR_Y, BAR_W, BAR_H);

          uint32_t fill_w = (uint32_t)((id(brightness_control).state / 100.0f) * (BAR_W - 4));
          if (fill_w > 0)
            it.filled_rectangle(BAR_X + 2, BAR_Y + 2, fill_w, BAR_H - 4);

      # ============================================
      # NOTIFICATION PAGE DISPLAY
      # ============================================
      - id: page_notification
        lambda: |-
          // ============================================
          // Display Configuration
          // ============================================
          static constexpr uint8_t TEXT_START_Y = 16;
          static constexpr uint8_t TEXT_CLIP_TOP = 18;
          static constexpr uint8_t CONTENT_BOTTOM = 62;
          static constexpr uint8_t CONTENT_BOTTOM_WITH_BUTTON = 48;
          static constexpr uint8_t MAX_LINE_WIDTH = 124;
          static constexpr uint8_t MAX_LINES = 12;
          static constexpr uint8_t LINE_BUFFER_SIZE = 32;
          static constexpr uint8_t LARGE_FONT_LINE_SPACING = 12;
          static constexpr uint8_t SMALL_FONT_LINE_SPACING = 10;
          static constexpr uint8_t BOTTOM_GAP = 5;

          // Scroll animation timing
          static constexpr float SCROLL_SPEED_DOWN = 12.0f;
          static constexpr float SCROLL_SPEED_UP = 35.0f;
          static constexpr float EASE_TIME_DOWN = 1.2f;
          static constexpr float EASE_TIME_UP = 1.2f;
          static constexpr float PAUSE_AT_TOP = 2.5f;
          static constexpr float PAUSE_AT_BOTTOM = 2.5f;

          // ============================================
          // Easing Functions for Smooth Scrolling
          // ============================================
          static auto ease_in_out = [](float t) -> float
          {
            static constexpr float x1 = 0.37f, y1 = 0.12f, x2 = 0.40f, y2 = 1.0f;

            float current_t = t;
            for (int i = 0; i < 4; i++)
            {
              float current_x =
                3.0f * (1.0f - current_t) * (1.0f - current_t) * current_t * x1 +
                3.0f * (1.0f - current_t) * current_t * current_t * x2 +
                current_t * current_t * current_t;

              float current_slope =
                3.0f * (1.0f - current_t) * (1.0f - current_t) * x1 +
                6.0f * (1.0f - current_t) * current_t * (x2 - x1) +
                3.0f * current_t * current_t * (1.0f - x2);

              if (current_slope == 0.0f)
                break;

              current_t -= (current_x - t) / current_slope;
            }

            return
              3.0f * (1.0f - current_t) * (1.0f - current_t) * current_t * y1 +
              3.0f * (1.0f - current_t) * current_t * current_t * y2 +
              current_t * current_t * current_t;
          };

          static auto ease_in = [](float t) -> float
          {
            return ease_in_out(t * 0.5f) * 2.0f;
          };

          static auto ease_out = [](float t) -> float
          {
            return (ease_in_out(0.5f + t * 0.5f) - 0.5f) * 2.0f;
          };

          static const float ease_in_scale = ease_in(1.0f);
          static const float ease_out_start = ease_out(0.0f);
          static const float ease_out_scale = 1.0f - ease_out_start;

          // ============================================
          // Scroll State Machine
          // ============================================
          enum class ScrollPhase : uint8_t
          {
            PAUSED_AT_TOP = 0,
            SCROLLING_DOWN = 1,
            PAUSED_AT_BOTTOM = 2,
            SCROLLING_UP = 3
          };

          static auto calculate_scroll_with_easing = [](float start_pos, float distance,
                                                        float speed, float ease_time,
                                                        float time_elapsed, int8_t direction,
                                                        bool& is_complete) -> float
          {
            float ideal_ease = 0.5f * speed * ease_time;
            float ease_dist = (distance < 2.0f * ideal_ease) ? (distance * 0.5f) : ideal_ease;
            float linear_dist = distance - (2.0f * ease_dist);
            if (linear_dist < 0.0f)
              linear_dist = 0.0f;

            float linear_time = linear_dist / speed;
            float total_time = ease_time + linear_time + ease_time;

            is_complete = (time_elapsed >= total_time);
            if (is_complete)
              return start_pos + direction * distance;

            float position = start_pos;

            if (time_elapsed < ease_time)
            {
              float progress = time_elapsed / ease_time;
              position += direction * (ease_in(progress) / ease_in_scale) * ease_dist;
            }
            else if (time_elapsed < ease_time + linear_time)
            {
              float linear_progress = time_elapsed - ease_time;
              position += direction * (ease_dist + linear_progress * speed);
            }
            else
            {
              float progress = (time_elapsed - ease_time - linear_time) / ease_time;
              position += direction * (ease_dist + linear_dist +
                                    ((ease_out(progress) - ease_out_start) / ease_out_scale) * ease_dist);
            }

            return position;
          };

          // ============================================
          // Persistent State Variables
          // ============================================
          static char cached_message[1024];
          static char cached_button[64];
          static char lines[MAX_LINES][LINE_BUFFER_SIZE];
          static uint8_t line_count = 0;
          static esphome::font::Font* font = id(font6x12);
          static uint8_t line_spacing = SMALL_FONT_LINE_SPACING;

          static float scroll_position = 0.0f;
          static float phase_start_scroll = 0.0f;
          static uint32_t phase_start_time = 0;
          static ScrollPhase current_phase = ScrollPhase::PAUSED_AT_TOP;

          static uint16_t total_height = 0;
          static float max_scroll = 0.0f;

          // ============================================
          // Get Current Frame Data
          // ============================================
          uint32_t now = millis();
          const char* message = id(notification_message).c_str();
          const char* button = id(notification_button_text).c_str();
          bool button_present = (button[0] != '\0');
          uint8_t content_bottom = button_present ? CONTENT_BOTTOM_WITH_BUTTON : CONTENT_BOTTOM;
          uint8_t available_height = content_bottom - TEXT_START_Y;

          // ============================================
          // Handle Manual Reset Request
          // ============================================
          if (id(notification_needs_scroll_reset))
          {
            id(notification_needs_scroll_reset) = false;
            line_count = 0;
            scroll_position = 0.0f;
            phase_start_scroll = 0.0f;
            phase_start_time = now;
            current_phase = ScrollPhase::PAUSED_AT_TOP;
            cached_message[0] = '\0';
            cached_button[0] = '\0';
          }

          // ============================================
          // Detect Content Changes and Re-wrap Text
          // ============================================
          bool message_changed = (strcmp(message, cached_message) != 0);
          bool button_changed = (strcmp(button, cached_button) != 0);

          if (message_changed || button_changed)
          {
            strncpy(cached_message, message, sizeof(cached_message) - 1);
            cached_message[sizeof(cached_message) - 1] = '\0';
            strncpy(cached_button, button, sizeof(cached_button) - 1);
            cached_button[sizeof(cached_button) - 1] = '\0';

            scroll_position = 0.0f;
            phase_start_scroll = 0.0f;
            current_phase = ScrollPhase::PAUSED_AT_TOP;
            phase_start_time = now;

            // Try large font first, fall back to small if content doesn't fit
            for (uint8_t attempt = 0; attempt <= 1; attempt++)
            {
              bool use_large = (attempt == 0);
              font = use_large ? id(font7x13) : id(font6x12);
              line_spacing = use_large ? LARGE_FONT_LINE_SPACING : SMALL_FONT_LINE_SPACING;
              line_count = 0;

              // ============================================
              // Word-wrap Helper Functions
              // ============================================
              auto text_fits = [&](const char* text) -> bool
              {
                int bx, by, bw, bh;
                it.get_text_bounds(0, 0, text, font, TextAlign::TOP_LEFT, &bx, &by, &bw, &bh);
                return bw <= MAX_LINE_WIDTH;
              };

              auto flush_line = [&](char* line_buffer, size_t len)
              {
                if (line_count < MAX_LINES)
                {
                  line_buffer[len] = '\0';
                  strncpy(lines[line_count], line_buffer, LINE_BUFFER_SIZE - 1);
                  lines[line_count][LINE_BUFFER_SIZE - 1] = '\0';
                  line_count++;
                }
              };

              // ============================================
              // Word-wrap the Message
              // ============================================
              char current_line[LINE_BUFFER_SIZE];
              size_t line_len = 0;
              current_line[0] = '\0';

              const char* p = message;

              while (*p != '\0' && line_count < MAX_LINES)
              {
                // Handle explicit newline
                if (*p == '\n')
                {
                  flush_line(current_line, line_len);
                  line_len = 0;
                  current_line[0] = '\0';
                  p++;
                  continue;
                }

                // Extract token (word or space sequence)
                const char* token_start = p;
                const char* token_end = p;
                bool is_space = (*p == ' ');

                if (is_space)
                {
                  while (*token_end == ' ')
                    token_end++;
                }
                else
                {
                  while (*token_end != '\0' && *token_end != ' ' && *token_end != '\n')
                    token_end++;
                }

                size_t token_length = token_end - token_start;
                size_t needed_len = line_len + token_length;

                // Try adding entire token to current line
                if (needed_len < LINE_BUFFER_SIZE)
                {
                  char test[LINE_BUFFER_SIZE];
                  memcpy(test, current_line, line_len);
                  memcpy(test + line_len, token_start, token_length);
                  test[needed_len] = '\0';

                  if (text_fits(test))
                  {
                    // Token fits completely
                    memcpy(current_line, test, needed_len + 1);
                    line_len = needed_len;
                    p = token_end;
                    continue;
                  }
                }

                // Token doesn't fit completely

                // Single space that doesn't fit at end of line - just skip it
                if (is_space && token_length == 1)
                {
                  p = token_end;
                  continue;
                }

                // For words that would fit on a fresh line: wrap to new line first
                if (!is_space && line_len > 0)
                {
                  // Check if word would fit on empty line
                  if (token_length < LINE_BUFFER_SIZE)
                  {
                    char test[LINE_BUFFER_SIZE];
                    memcpy(test, token_start, token_length);
                    test[token_length] = '\0';

                    if (text_fits(test))
                    {
                      // Word would fit on fresh line - wrap normally
                      // Remove trailing space from current line if present (for centered rendering)
                      if (current_line[line_len - 1] == ' ')
                      {
                        line_len--;
                      }

                      flush_line(current_line, line_len);
                      line_len = 0;
                      current_line[0] = '\0';
                      continue; // Retry token on fresh line
                    }
                  }
                  // Word is too long even for empty line - continue from current line
                }

                // Token still doesn't fit (long word on empty line, or spaces)
                // Add character-by-character (splits long tokens)
                while (p < token_end && line_count < MAX_LINES)
                {
                  // Check buffer space
                  if (line_len >= LINE_BUFFER_SIZE - 1)
                  {
                    flush_line(current_line, line_len);
                    line_len = 0;
                    current_line[0] = '\0';
                  }

                  // Try adding next character
                  char test[LINE_BUFFER_SIZE];
                  memcpy(test, current_line, line_len);
                  test[line_len] = *p;
                  test[line_len + 1] = '\0';

                  if (text_fits(test))
                  {
                    // Character fits
                    current_line[line_len] = *p;
                    line_len++;
                    current_line[line_len] = '\0';
                    p++;
                  }
                  else
                  {
                    // Character doesn't fit - wrap
                    if (line_len > 0)
                    {
                      flush_line(current_line, line_len);
                      line_len = 0;
                      current_line[0] = '\0';
                    }
                    else
                    {
                      // Single character doesn't fit empty line - skip it
                      p++;
                    }
                  }
                }
              }

              // Flush remaining content
              if (line_len > 0 && line_count < MAX_LINES)
                flush_line(current_line, line_len);

              // ============================================
              // Add Ellipsis if We Hit Line Limit
              // ============================================
              if (line_count == MAX_LINES)
              {
                uint8_t last_idx = line_count - 1;
                char* last_line = lines[last_idx];
                size_t current_len = strlen(last_line);
                char test[LINE_BUFFER_SIZE];
                int bx, by, bw, bh;

                // Always try to add ellipsis when we hit max lines
                // Start by removing characters until "..." fits
                while (current_len > 0)
                {
                  // Check buffer space
                  if (current_len + 4 > LINE_BUFFER_SIZE)
                  {
                    current_len--;
                    continue;
                  }

                  // Build test string with shortened text + "..."
                  strncpy(test, last_line, current_len);
                  test[current_len] = '\0';
                  strcat(test, "...");

                  // Check if it fits on screen
                  it.get_text_bounds(0, 0, test, font, TextAlign::TOP_LEFT, &bx, &by, &bw, &bh);

                  if (bw <= MAX_LINE_WIDTH)
                  {
                    strcpy(last_line, test);
                    break;
                  }

                  current_len--;
                }

                // Fallback: just "..." if nothing fits
                if (current_len == 0)
                  strcpy(last_line, "...");
              }

              total_height = line_count * line_spacing;

              // Use this font if content fits, otherwise try smaller
              if (total_height <= available_height)
                break;
            }

            max_scroll = (total_height > available_height)
                        ? (total_height - available_height + BOTTOM_GAP)
                        : 0.0f;
          }

          // ============================================
          // Update Scroll Animation
          // ============================================
          int16_t vertical_offset = 0;

          if (max_scroll <= 0.0f)
          {
            // No scrolling necessary
            vertical_offset = (available_height - total_height) / 2;

            if (!button_present && line_count <= 3)
              vertical_offset = std::max(0, vertical_offset - 4);
          }
          else
          {
            // Do scrolling
            uint32_t elapsed_millis = now - phase_start_time;
            float time_in_phase = elapsed_millis / 1000.0f;

            // Scrolling state machine
            switch (current_phase)
            {
              case ScrollPhase::PAUSED_AT_TOP:
                if (time_in_phase >= PAUSE_AT_TOP)
                {
                  current_phase = ScrollPhase::SCROLLING_DOWN;
                  phase_start_time = now;
                  phase_start_scroll = 0.0f;
                }
                scroll_position = 0.0f;
                break;

              case ScrollPhase::SCROLLING_DOWN:
              {
                bool scroll_complete = false;
                scroll_position = calculate_scroll_with_easing(
                  phase_start_scroll, max_scroll, SCROLL_SPEED_DOWN,
                  EASE_TIME_DOWN, time_in_phase, 1, scroll_complete);

                if (scroll_complete)
                {
                  current_phase = ScrollPhase::PAUSED_AT_BOTTOM;
                  phase_start_time = now;
                  phase_start_scroll = scroll_position;
                }
                scroll_position = std::max(0.0f, std::min(scroll_position, max_scroll));
                break;
              }

              case ScrollPhase::PAUSED_AT_BOTTOM:
                if (time_in_phase >= PAUSE_AT_BOTTOM)
                {
                  current_phase = ScrollPhase::SCROLLING_UP;
                  phase_start_time = now;
                  phase_start_scroll = max_scroll;
                }
                scroll_position = max_scroll;
                break;

              case ScrollPhase::SCROLLING_UP:
              {
                bool scroll_complete = false;
                scroll_position = calculate_scroll_with_easing(
                  phase_start_scroll, max_scroll, SCROLL_SPEED_UP,
                  EASE_TIME_UP, time_in_phase, -1, scroll_complete);

                if (scroll_complete)
                {
                  current_phase = ScrollPhase::PAUSED_AT_TOP;
                  phase_start_time = now;
                  phase_start_scroll = scroll_position;
                }
                scroll_position = std::max(0.0f, std::min(scroll_position, max_scroll));
                break;
              }
            }
          }

          // ============================================
          // Render Notification
          // ============================================

          // Border
          if (id(notification_show_border))
            it.rectangle(0, 0, 128, 64);

          // ============================================
          // Title with ellipsis if needed
          char title_buffer[48];
          const char* title = id(notification_title).c_str();
          int bx, by, bw, bh;
          it.get_text_bounds(0, 0, title, id(font_ui_15_bold), TextAlign::TOP_LEFT, &bx, &by, &bw, &bh);

          if (bw > 120)
          {
            size_t len = strlen(title);
            size_t max_len = (sizeof(title_buffer) > 4) ? (sizeof(title_buffer) - 4) : 0;

            if (len > max_len)
              len = max_len;

            while (len > 0)
            {
              strncpy(title_buffer, title, len);
              title_buffer[len] = '\0';
              strcat(title_buffer, "...");

              it.get_text_bounds(0, 0, title_buffer, id(font_ui_15_bold), TextAlign::TOP_LEFT, &bx, &by, &bw, &bh);

              if (bw <= 120)
                break;

              len--;
            }

            if (len == 0)
              strcpy(title_buffer, "...");
          }
          else
          {
            strncpy(title_buffer, title, sizeof(title_buffer) - 1);
            title_buffer[sizeof(title_buffer) - 1] = '\0';
          }

          it.printf(64, -3, id(font_ui_15_bold), TextAlign::TOP_CENTER, "%s", title_buffer);

          // ============================================
          // Message text
          it.start_clipping(0, TEXT_CLIP_TOP, 128, content_bottom);

          for (uint8_t i = 0; i < line_count; i++)
          {
            int16_t y = TEXT_START_Y + vertical_offset + (i * line_spacing) - scroll_position;
            it.printf(64, y, font, TextAlign::TOP_CENTER, "%s", lines[i]);
          }

          it.end_clipping();

          // ============================================
          // Button with ellipsis if needed
          if (button_present)
          {
            char button_buffer[48];
            it.get_text_bounds(0, 0, button, id(font7x13B), TextAlign::TOP_LEFT, &bx, &by, &bw, &bh);

            if (bw > 115)
            {
              size_t len = strlen(button);
              size_t max_len = (sizeof(button_buffer) > 4) ? (sizeof(button_buffer) - 4) : 0;

              if (len > max_len)
                len = max_len;

              while (len > 0)
              {
                strncpy(button_buffer, button, len);
                button_buffer[len] = '\0';
                strcat(button_buffer, "...");

                it.get_text_bounds(0, 0, button_buffer, id(font7x13B), TextAlign::TOP_LEFT, &bx, &by, &bw, &bh);

                if (bw <= 115)
                  break;

                len--;
              }

              if (len == 0)
                strcpy(button_buffer, "...");

              it.get_text_bounds(0, 0, button_buffer, id(font7x13B), TextAlign::TOP_LEFT, &bx, &by, &bw, &bh);
            }
            else
            {
              strncpy(button_buffer, button, sizeof(button_buffer) - 1);
              button_buffer[sizeof(button_buffer) - 1] = '\0';
            }

            uint16_t button_width = std::min((uint16_t)(bw + 11), (uint16_t)126);
            uint8_t button_x = 64 - (button_width / 2);

            it.filled_rectangle(button_x - 1, 51, button_width, 11);
            it.printf(64, 50, id(font7x13B), COLOR_OFF, TextAlign::TOP_CENTER, "%s", button_buffer);
          }

      # ============================================
      # MENU
      # ============================================
      - id: page_menu
        lambda: |-
          it.menu(0, 0, id(main_menu), 128, 64);

      # ============================================
      # HISTORY GRAPHS
      # ============================================
      # Temperature
      - id: page_menu_history_temp
        lambda: |-
          it.graph(0, 0, id(graph_temp));

          const int32_t minutes = id(graph_duration_minutes);
          if (minutes < 60)
          {
            it.printf(1, 64, id(font6x12), TextAlign::BOTTOM_LEFT, "%dmin", minutes);
          }
          else
          {
            const int32_t hours = minutes / 60;
            const int32_t remaining_mins = minutes % 60;

            if (remaining_mins == 0)
              it.printf(1, 64, id(font6x12), TextAlign::BOTTOM_LEFT, "%dh", hours);
            else
              it.printf(1, 64, id(font6x12), TextAlign::BOTTOM_LEFT, "%dh %dm", hours, remaining_mins);
          }

          it.printf(127, 64, id(font6x12), TextAlign::BOTTOM_RIGHT, "Temp: %.1f°C", id(sensor_temperature).state);

      # Humidity
      - id: page_menu_history_humid
        lambda: |-
          it.graph(0, 0, id(graph_humid));

          const int32_t minutes = id(graph_duration_minutes);
          if (minutes < 60)
          {
            it.printf(1, 66, id(font6x12), TextAlign::BOTTOM_LEFT, "%dmin", minutes);
          }
          else
          {
            const int32_t hours = minutes / 60;
            const int32_t remaining_mins = minutes % 60;

            if (remaining_mins == 0)
              it.printf(1, 66, id(font6x12), TextAlign::BOTTOM_LEFT, "%dh", hours);
            else
              it.printf(1, 66, id(font6x12), TextAlign::BOTTOM_LEFT, "%dh %dm", hours, remaining_mins);
          }

          it.printf(127, 66, id(font6x12), TextAlign::BOTTOM_RIGHT, "Humid: %.1f%%", id(sensor_humidity).state);

      # Air Quality
      - id: page_menu_history_aqi
        lambda: |-
          it.graph(0, 0, id(graph_aqi));

          const int32_t minutes = id(graph_duration_minutes);
          if (minutes < 60)
          {
            it.printf(1, 65, id(font6x12), TextAlign::BOTTOM_LEFT, "%dmin", minutes);
          }
          else
          {
            const int32_t hours = minutes / 60;
            const int32_t remaining_mins = minutes % 60;

            if (remaining_mins == 0)
              it.printf(1, 65, id(font6x12), TextAlign::BOTTOM_LEFT, "%dh", hours);
            else
              it.printf(1, 65, id(font6x12), TextAlign::BOTTOM_LEFT, "%dh %dm", hours, remaining_mins);
          }

          if (id(sensor_aqi).has_state())
            it.printf(127, 65, id(font6x12), TextAlign::BOTTOM_RIGHT, "AQI: %u", (uint32_t)id(sensor_aqi).state);
          else
            it.printf(122, 65, id(font6x12), TextAlign::BOTTOM_RIGHT, "AQI: ---");

      # eCO2
      - id: page_menu_history_eco2
        lambda: |-
          it.graph(0, 0, id(graph_eco2));

          const int32_t minutes = id(graph_duration_minutes);
          if (minutes < 60)
          {
            it.printf(1, 64, id(font6x12), TextAlign::BOTTOM_LEFT, "%dmin", minutes);
          }
          else
          {
            const int32_t hours = minutes / 60;
            const int32_t remaining_mins = minutes % 60;

            if (remaining_mins == 0)
              it.printf(1, 64, id(font6x12), TextAlign::BOTTOM_LEFT, "%dh", hours);
            else
              it.printf(1, 64, id(font6x12), TextAlign::BOTTOM_LEFT, "%dh %dm", hours, remaining_mins);
          }

          if (id(sensor_eco2).has_state())
            it.printf(127, 64, id(font6x12), TextAlign::BOTTOM_RIGHT, "eCO2: %uppm", (uint32_t)id(sensor_eco2).state);
          else
            it.printf(122, 64, id(font6x12), TextAlign::BOTTOM_RIGHT, "eCO2: ---");


      # TVOC
      - id: page_menu_history_tvoc
        lambda: |-
          it.graph(0, 0, id(graph_tvoc));

          const int32_t minutes = id(graph_duration_minutes);
          if (minutes < 60)
          {
            it.printf(1, 64, id(font6x12), TextAlign::BOTTOM_LEFT, "%dmin", minutes);
          }
          else
          {
            const int32_t hours = minutes / 60;
            const int32_t remaining_mins = minutes % 60;

            if (remaining_mins == 0)
              it.printf(1, 64, id(font6x12), TextAlign::BOTTOM_LEFT, "%dh", hours);
            else
              it.printf(1, 64, id(font6x12), TextAlign::BOTTOM_LEFT, "%dh %dm", hours, remaining_mins);
          }

          if (id(sensor_tvoc).has_state())
            it.printf(127, 64, id(font6x12), TextAlign::BOTTOM_RIGHT, "TVOC: %uppb", (uint32_t)id(sensor_tvoc).state);
          else
            it.printf(122, 64, id(font6x12), TextAlign::BOTTOM_RIGHT, "TVOC: ---");

      # ============================================
      # MENU DETAIL: Sleep Time
      # ============================================
      - id: page_menu_sleep_config
        lambda: |-
          // Header
          it.printf(64, -4, id(font_ui_18_bold), TextAlign::TOP_CENTER, "Sleep Time");

          // Display value
          const int32_t seconds = id(sleep_timeout_milliseconds) / 1000;
          if (seconds == 0)
          {
            it.printf(64, 26, id(font_ui_15_bold), TextAlign::TOP_CENTER, "DISABLED");
          }
          else if (seconds < 60)
          {
            it.printf(64, 14, id(font_number_large), TextAlign::TOP_CENTER, "%ds", seconds);
          }
          else
          {
            const int32_t minutes = seconds / 60;
            if (minutes >= 60)
            {
              const int32_t hours = minutes / 60;
              const int32_t remaining_mins = minutes % 60;

              if (remaining_mins == 0)
                it.printf(64, 14, id(font_number_large), TextAlign::TOP_CENTER, "%dh", hours);
              else
                it.printf(64, 14, id(font_number_large), TextAlign::TOP_CENTER, "%dh %dm", hours, remaining_mins);
            }
            else
            {
              it.printf(64, 14, id(font_number_large), TextAlign::TOP_CENTER, "%dm", minutes);
            }
          }

          // ——— Visual step indicators (bottom row) ———
          const int32_t TOTAL_DOTS  = (seconds >= 60 && seconds <= 600) ? 10 : 11;
          const int32_t DOT_SPACING = 10;
          const int32_t DOT_X_START = 64 - ( ((TOTAL_DOTS - 1) * DOT_SPACING) / 2 );
          const int32_t DOT_Y       = 60;

          for (int32_t i = 0; i < TOTAL_DOTS; i++)
          {
            int32_t x = DOT_X_START + i * DOT_SPACING;
            bool active = false;

            if (seconds < 60)
            {
              const int32_t cur = (seconds / 5) - 1;
              if (cur == i)
                active = true;
            }
            else if (seconds >= 60 && seconds <= 600)
            {
              const int32_t cur = (seconds / 60) - 1;
              if (cur == i)
                active = true;
            }
            else if (seconds > 600)
            {
              const int32_t cur = (seconds / 600) - 2;
              if (cur == i)
                active = true;
            }

            if (active)
              it.filled_circle(x, DOT_Y, 3);
            else
              it.circle(x, DOT_Y, 3);
          }

      # ============================================
      # MENU DETAIL: Graph Duration
      # ============================================
      - id: page_menu_graph_duration
        lambda: |-
          // Header
          it.printf(64, -4, id(font_ui_18_bold), TextAlign::TOP_CENTER, "Graph Duration");

          // Display value
          const int32_t minutes = id(graph_duration_minutes);
          if (minutes < 60)
          {
            it.printf(64, 14, id(font_number_large), TextAlign::TOP_CENTER, "%dm", minutes);
          }
          else
          {
            const int32_t hours = minutes / 60;
            const int32_t remaining_mins = minutes % 60;

            if (remaining_mins == 0)
              it.printf(64, 14, id(font_number_large), TextAlign::TOP_CENTER, "%dh", hours);
            else
              it.printf(64, 14, id(font_number_large), TextAlign::TOP_CENTER, "%dh %dm", hours, remaining_mins);
          }

          // ——— Visual step indicators (bottom row) ———
          int32_t TOTAL_DOTS;
          if (minutes <= 9)
            TOTAL_DOTS = 9;
          else if (minutes > 9 && minutes <= 50)
            TOTAL_DOTS = 5;
          else if (minutes > 50)
            TOTAL_DOTS = 12;

          const int32_t DOT_SPACING = 10;
          const int32_t DOT_X_START = 64 - ( ((TOTAL_DOTS - 1) * DOT_SPACING) / 2 );
          const int32_t DOT_Y       = 60;

          for (int32_t i = 0; i < TOTAL_DOTS; i++)
          {
            int32_t x = DOT_X_START + i * DOT_SPACING;
            bool active = false;

            if (minutes <= 9)
            {
              const int32_t cur = minutes - 1;
              if (cur == i)
                active = true;
            }
            else if (minutes > 9 && minutes <= 50)
            {
              const int32_t cur = (minutes / 10) - 1;
              if (cur == i)
                active = true;
            }
            else if (minutes > 50)
            {
              const int32_t cur = ((minutes + 60) / 120) - 1;
              if (cur == i)
                active = true;
            }

            if (active)
              it.filled_circle(x, DOT_Y, 3);
            else
              it.circle(x, DOT_Y, 3);
          }

      # ============================================
      # MENU DETAIL: Graph Duration Change Reboot Confirmation
      # ============================================
      - id: page_graph_duration_restart_confirm
        lambda: |-
          // Header with info icon
          it.image(4, 5, id(icon_info_big));
          it.printf(77, 0, id(font_ui_18_bold), TextAlign::TOP_CENTER, "Reboot");
          it.printf(77, 16, id(font_ui_18_bold), TextAlign::TOP_CENTER, "required");

          // OK button
          const uint32_t button_width = 41;
          it.filled_rectangle(64 - (button_width / 2), 44, button_width, 19);
          it.printf(64, 42, id(font_ui_15_bold), COLOR_OFF, TextAlign::TOP_CENTER, "OK");

      # ============================================
      # MENU DETAIL: About
      # ============================================
      - id: page_menu_about
        lambda: |-
          it.printf(63, 0, id(font_ui_21_bold), TextAlign::TOP_CENTER, "ObsidianHub");
          it.printf(63, 35, id(font_ui_15_bold), TextAlign::CENTER, "v${version}");
          it.image(1, 52, id(icon_copyright));

      # ============================================
      # MENU DETAIL: Connection Status
      # ============================================
      - id: page_menu_connection_status
        lambda: |-
          it.image(4, 2, id(icon_wifi));
          it.printf(75, -2, id(font_ui_18_bold), TextAlign::TOP_CENTER, "Connection");

          // WiFi status
          it.printf(1, 24, id(font7x13), TextAlign::TOP_LEFT, "WiFi:");
          it.printf(127, 24, id(font7x13B), TextAlign::TOP_RIGHT, "%s", id(component_wifi).is_connected() ? "Connected" : "Disconnected");

          // API status (Home Assistant)
          it.printf(1, 37, id(font7x13), TextAlign::TOP_LEFT, "HA:");
          it.printf(127, 37, id(font7x13B), TextAlign::TOP_RIGHT, "%s", id(component_api).is_connected() ? "Connected" : "Disconnected");

          // MQTT status
          it.printf(1, 50, id(font7x13), TextAlign::TOP_LEFT, "MQTT:");
          it.printf(127, 50, id(font7x13B), TextAlign::TOP_RIGHT, "%s", id(mqtt_component).is_connected() ? "Connected" : "Disconnected");

      # ============================================
      # MENU DETAIL: System Info
      # ============================================
      - id: page_menu_system_info
        lambda: |-
          it.image(1, 0, id(icon_gear));
          it.printf(75, -2, id(font_ui_18_bold), TextAlign::TOP_CENTER, "System Info");

          // Free memory
          it.printf(1, 26, id(font7x13), TextAlign::TOP_LEFT, "Free RAM:");
          it.printf(127, 26, id(font7x13B), TextAlign::TOP_RIGHT, "%.1f KB", esp_get_free_heap_size() / 1024.0f);

      # ============================================
      # MENU DETAIL: WiFi Status
      # ============================================
      - id: page_menu_wifi_status
        lambda: |-
          it.image(4, 1, id(icon_wifi));
          it.printf(76, -3, id(font_ui_18_bold), TextAlign::TOP_CENTER, "WiFi Status");

          if (id(component_wifi).is_connected())
          {
            // IP
            it.printf(1, 20, id(font6x12), TextAlign::TOP_LEFT, "IP:");
            auto ips = network::get_ip_addresses();
            if (!ips.empty())
              it.printf(127, 20, id(font6x12), TextAlign::TOP_RIGHT, "%s", ips[0].str().c_str());

            // SSID
            it.printf(1, 31, id(font6x12), TextAlign::TOP_LEFT, "SSID:");
            it.printf(127, 31, id(font6x12), TextAlign::TOP_RIGHT, "%s", id(component_wifi).wifi_ssid().c_str());

            // Signal strength
            it.printf(1, 42, id(font6x12), TextAlign::TOP_LEFT, "Signal:");
            it.printf(127, 42, id(font6x12), TextAlign::TOP_RIGHT, "%.0f%%", id(sensor_wifi_signal_percentage).state);

            // MAC
            it.printf(64, 53, id(font6x12), TextAlign::TOP_CENTER, "%s", get_mac_address_pretty().c_str());
          }
          else
          {
            it.printf(64, 40, id(font_ui_15_bold), TextAlign::CENTER, "Not Connected");
          }

###############################################################
# Graphical Display Menu
###############################################################
graphical_display_menu:
  id: main_menu
  font: font_ui_15_bold
  mode: rotary
  active: true
  items:
    # Back - close menu
    - type: command
      text: "< Back"
      on_value:
        then:
          - lambda: |-
              // Force save preferences to flash immediately
              global_preferences->sync();
              id(is_menu_detail_visible) = false;
              id(is_menu_visible) = false;
              id(return_to_current_dashboard).execute();

    # Sub-Menu: Histories
    - type: menu
      text: "History Graphs"
      items:
        - type: back
          text: "< Back"
        - type: command
          text: "Temperature"
          on_value:
            then:
              - lambda: |-
                  id(main_display).show_page(id(page_menu_history_temp));
                  id(is_menu_detail_visible) = true;
                  id(is_menu_visible) = false;
        - type: command
          text: "Humidity"
          on_value:
            then:
              - lambda: |-
                  id(main_display).show_page(id(page_menu_history_humid));
                  id(is_menu_detail_visible) = true;
                  id(is_menu_visible) = false;
        - type: command
          text: "Air Quality"
          on_value:
            then:
              - lambda: |-
                  id(main_display).show_page(id(page_menu_history_aqi));
                  id(is_menu_detail_visible) = true;
                  id(is_menu_visible) = false;
        - type: command
          text: "eCO2"
          on_value:
            then:
              - lambda: |-
                  id(main_display).show_page(id(page_menu_history_eco2));
                  id(is_menu_detail_visible) = true;
                  id(is_menu_visible) = false;
        - type: command
          text: "TVOC"
          on_value:
            then:
              - lambda: |-
                  id(main_display).show_page(id(page_menu_history_tvoc));
                  id(is_menu_detail_visible) = true;
                  id(is_menu_visible) = false;

    # Sub-Menu: Settings
    - type: menu
      text: "Settings"
      items:
        # Back
        - type: back
          text: "< Back"

        # History graph duration (x-axis)
        - type: command
          text: !lambda |-
            static char buf[32];
            uint32_t min = id(graph_duration_minutes);
            if (min >= 60) {
              uint32_t h = min / 60;
              uint32_t m = min % 60;
              if (m == 0)
                snprintf(buf, sizeof(buf), "Graph: %dh", h);
              else
                snprintf(buf, sizeof(buf), "Graph: %dh%dm", h, m);
            } else {
              snprintf(buf, sizeof(buf), "Graph: %dm", min);
            }
            return buf;
          on_value:
            then:
              - lambda: |-
                  id(main_display).show_page(id(page_menu_graph_duration));
                  id(is_menu_detail_visible) = true;
                  id(is_menu_visible) = false;

        # Auto sleep time configuration
        - type: command
          text: !lambda |-
            static char buf[32];
            uint32_t sec = id(sleep_timeout_milliseconds) / 1000;
            if (sec == 0)
            {
              snprintf(buf, sizeof(buf), "Sleep Time: OFF");
            }
            else if (sec < 60)
            {
              snprintf(buf, sizeof(buf), "Sleep Time: %ds", sec);
            }
            else
            {
              uint32_t min = sec / 60;
              if (min >= 60)
              {
                uint32_t h = min / 60;
                uint32_t m = min % 60;
                if (m == 0)
                  snprintf(buf, sizeof(buf), "Sleep Time: %dh", h);
                else
                  snprintf(buf, sizeof(buf), "Sleep Time: %dh%dm", h, m);
              }
              else
              {
                snprintf(buf, sizeof(buf), "Sleep Time: %dm", min);
              }
            }
            return buf;
          on_value:
            then:
              - lambda: |-
                  id(main_display).show_page(id(page_menu_sleep_config));
                  id(is_menu_detail_visible) = true;
                  id(is_menu_visible) = false;

        # Sleep components select
        - type: select
          immediate_edit: false
          text: "Sleep"
          select: select_sleep_components

        # Display brightness
        - type: custom
          immediate_edit: false
          text: "Brightness"
          value_lambda: 'return to_string((uint32_t)(id(display_brightness) * 100.0f)) + "%";'
          on_next:
            then:
              - lambda: |-
                  uint32_t new_val = (uint32_t)(id(display_brightness) * 100.0f) + 10;
                  if (new_val > 100)
                    new_val = 100;
                  id(display_brightness) = (float)new_val / 100.0f;
          on_prev:
            then:
              - lambda: |-
                  uint32_t new_val = (uint32_t)(id(display_brightness) * 100.0f) - 10;
                  if (new_val < 10)
                    new_val = 10;
                  id(display_brightness) = (float)new_val / 100.0f;
          on_value:
            then:
              - lambda: |-
                  uint32_t val = stoi(it->get_value_text());
                  id(display_brightness) = (float)val / 100.0f;
                  id(main_display).set_contrast(id(display_brightness));
                  id(config_display_brightness).publish_state(val);

        # Auto Dim Display
        - type: switch
          immediate_edit: false
          text: "Auto Dim"
          on_text: "ON"
          off_text: "OFF"
          switch: switch_auto_dim_display

        # Invert Display
        - type: switch
          immediate_edit: false
          text: "Inv Display"
          on_text: "ON"
          off_text: "OFF"
          switch: switch_invert_display

     # Sub-Menu: Info
    - type: menu
      text: "Info"
      items:
        # Back
        - type: back
          text: "< Back"

        # Device Info
        - type: command
          text: "About"
          on_value:
            then:
              - lambda: |-
                  id(main_display).show_page(id(page_menu_about));
                  id(is_menu_detail_visible) = true;
                  id(is_menu_visible) = false;

        # Connection Status
        - type: command
          text: "Connection Status"
          on_value:
            then:
              - lambda: |-
                  id(main_display).show_page(id(page_menu_connection_status));
                  id(is_menu_detail_visible) = true;
                  id(is_menu_visible) = false;

        # System Info
        - type: command
          text: "System Info"
          on_value:
            then:
              - lambda: |-
                  id(main_display).show_page(id(page_menu_system_info));
                  id(is_menu_detail_visible) = true;
                  id(is_menu_visible) = false;

        # Wifi Status
        - type: command
          text: "WiFi Status"
          on_value:
            then:
              - lambda: |-
                  id(main_display).show_page(id(page_menu_wifi_status));
                  id(is_menu_detail_visible) = true;
                  id(is_menu_visible) = false;

        # Uptime
        - type: command
          text: !lambda |-
            static char buf[48];
            static float scroll_pos = 0.0f;
            static uint32_t last_update = 0;
            static uint8_t pause_counter = 0;
            static bool scrolling_right = true;

            const uint8_t DISPLAY_WIDTH = 17;
            const uint8_t SCROLL_INTERVAL = 50;      // ms between scroll updates
            const uint8_t PAUSE_AT_START = 15;       // frames to pause at beginning
            const uint8_t PAUSE_AT_END = 20;         // frames to pause at end
            const float SCROLL_SPEED_FWD = 0.25f;    // chars per frame going right
            const float SCROLL_SPEED_BACK = 0.6f;    // chars per frame going left

            std::string full_text = "Uptime: " + id(text_sensor_uptime).state;
            int16_t text_length = full_text.length();

            // No scrolling needed for short text
            if (text_length <= DISPLAY_WIDTH)
            {
              snprintf(buf, sizeof(buf), "%s", full_text.c_str());
              return buf;
            }

            // Update scroll position at regular intervals
            uint32_t now = millis();
            if (now - last_update > SCROLL_INTERVAL)
            {
              last_update = now;

              // Handle pause at ends
              if (pause_counter > 0)
              {
                pause_counter--;
              }
              else
              {
                // Scroll logic
                int16_t max_scroll = text_length - DISPLAY_WIDTH;

                if (scrolling_right)
                {
                  scroll_pos += SCROLL_SPEED_FWD;

                  // Reached the end, start going back
                  if (scroll_pos >= max_scroll)
                  {
                    scroll_pos = max_scroll;
                    scrolling_right = false;
                    pause_counter = PAUSE_AT_END;
                  }
                }
                else
                {
                  scroll_pos -= SCROLL_SPEED_BACK;

                  // Reached the beginning, start going forward
                  if (scroll_pos <= 0)
                  {
                    scroll_pos = 0;
                    scrolling_right = true;
                    pause_counter = PAUSE_AT_START;
                  }
                }
              }
            }

            // Render visible part
            int16_t start_pos = (int16_t)scroll_pos;
            snprintf(buf, sizeof(buf), "%s", full_text.substr(start_pos, DISPLAY_WIDTH).c_str());
            return buf;

###############################################################
# Graphs
###############################################################
graph:
  # Temperature
  - id: graph_temp
    duration: 30min
    width: 128
    height: 52
    border: true
    x_grid: 30min   # 30min/div
    y_grid: 1       # units/div
    #min_value: 0
    #max_value: 0
    min_range: 2
    #max_range: 0
    traces:
      - sensor: sensor_temperature
        name: "Temp"
        continuous: true
        line_thickness: 4

  # Humidity
  - id: graph_humid
    duration: 30min
    width: 128
    height: 53
    border: true
    x_grid: 30min   # 30min/div
    y_grid: 10       # units/div
    #min_value: 0
    #max_value: 100
    min_range: 2
    #max_range: 100
    traces:
      - sensor: sensor_humidity
        name: "Humid"
        continuous: true
        line_thickness: 4

  # Air Quality
  - id: graph_aqi
    duration: 30min
    width: 128
    height: 53
    border: true
    x_grid: 30min    # 30min/div
    y_grid: 1        # units/div
    min_value: 0
    max_value: 5
    min_range: 5
    max_range: 5
    traces:
      - sensor: sensor_aqi
        name: "AQI"
        continuous: true
        line_thickness: 4

  # eCO2
  - id: graph_eco2
    duration: 30min
    width: 128
    height: 52
    border: true
    x_grid: 30min    # 30min/div
    y_grid: 250.0    # units/div
    min_value: 390
    #max_value: 65000
    #min_range: 0
    max_range: 65410
    traces:
      - sensor: sensor_eco2
        name: "eCO2"
        continuous: true
        line_thickness: 4

  # TVOC
  - id: graph_tvoc
    duration: 30min
    width: 128
    height: 52
    border: true
    x_grid: 30min    # 30min/div
    y_grid: 250.0    # units/div
    min_value: 0
    #max_value: 65000
    #min_range: 0
    max_range: 65000
    traces:
      - sensor: sensor_tvoc
        name: "TVOC"
        continuous: true
        line_thickness: 4

###############################################################
# RGB LED Configuration (SK6812 Addressable LEDs)
###############################################################
light:
  # Master LED strip controller (internal - not exposed to Home Assistant)
  - platform: esp32_rmt_led_strip
    name: "All LEDs"
    id: led_strip_controller
    rgb_order: GRB
    pin: GPIO3
    num_leds: 3
    chipset: SK6812
    max_refresh_rate: 12ms
    restore_mode: ALWAYS_OFF
    gamma_correct: 2.5
    default_transition_length: 600ms
    internal: true
    effects:
      - addressable_rainbow:
          name: "Rainbow"
          speed: 8
          width: 50

  # Individual LED partitions (exposed to Home Assistant)
  - platform: partition
    name: "Status LED"
    id: led_status
    restore_mode: ALWAYS_OFF
    segments:
      - id: led_strip_controller
        from: 0
        to: 0
    effects:
      - strobe:
          name: "Blue Pulse"
          colors:
            - state: true
              brightness: 100%
              red: 0%
              green: 0%
              blue: 100%
              duration: 2000ms
              transition_length: 1300ms
            - state: false
              duration: 550ms
              transition_length: 550ms
      - strobe:
          name: "Turquoise Pulse"
          colors:
            - state: true
              brightness: 100%
              red: 0%
              green: 100%
              blue: 85%
              duration: 2000ms
              transition_length: 1300ms
            - state: false
              duration: 550ms
              transition_length: 550ms
      - strobe:
          name: "Red Pulse"
          colors:
            - state: true
              brightness: 100%
              red: 100%
              green: 0%
              blue: 0%
              duration: 2000ms
              transition_length: 1300ms
            - state: false
              duration: 550ms
              transition_length: 550ms

  - platform: partition
    name: "Left Key LED"
    id: led_key1
    restore_mode: ALWAYS_OFF
    segments:
      - id: led_strip_controller
        from: 1
        to: 1

  - platform: partition
    name: "Right Key LED"
    id: led_key2
    restore_mode: ALWAYS_OFF
    segments:
      - id: led_strip_controller
        from: 2
        to: 2

###############################################################
# Sensors
###############################################################
sensor:
  # --- WiFi Status ---

  # Signal strength
  - platform: wifi_signal
    name: "WiFi Signal"
    id: sensor_wifi_signal
    entity_category: "diagnostic"
    update_interval: 20s

  - platform: copy
    source_id: sensor_wifi_signal
    name: "WiFi Signal Strength"
    id: sensor_wifi_signal_percentage
    icon: mdi:wifi
    filters:
      - lambda: return min(max(2.0f * (x + 100.0f), 0.0f), 100.0f);
    unit_of_measurement: "%"
    entity_category: "diagnostic"
    device_class: ""

  # --- Environmental Sensors ---

  # AHT20: Temperature and humidity
  - platform: aht10
    variant: AHT20
    update_interval: 10s  # Slower update prevents self-heating
    address: 0x38
    temperature:
      name: "Temperature"
      id: sensor_temperature
      accuracy_decimals: 2
    humidity:
      name: "Humidity"
      id: sensor_humidity
      accuracy_decimals: 2

  # BMP280: Atmospheric pressure
  - platform: bmp280_i2c
    address: 0x77
    update_interval: 30s
    iir_filter: 4x
    pressure:
      name: "Atmospheric Pressure"
      id: sensor_pressure
      oversampling: 16x

  # ENS160: Air quality sensor (eCO2, TVOC, AQI)
  - platform: ens160_spi
    cs_pin:
      number: GPIO2
      ignore_strapping_warning: true
    data_rate: 200kHz
    update_interval: 10s
    eco2:
      name: "eCO2"
      id: sensor_eco2
    tvoc:
      name: "TVOC (Total Volatile Organic Compounds)"
      id: sensor_tvoc
      icon: mdi:molecule
    aqi:
      name: "Air Quality Index"
      id: sensor_aqi
    compensation:
      temperature: sensor_temperature
      humidity: sensor_humidity

  # BH1750: Ambient light sensor
  - platform: bh1750
    name: "Illuminance"
    id: sensor_brightness
    address: 0x23
    update_interval: 1500ms

  # --- User Input Sensors ---

  # Rotary encoder
  - platform: rotary_encoder
    name: "Rotary Encoder"
    id: encoder_input
    pin_a:
      number: GPIO7
      inverted: true
    pin_b:
      number: GPIO10
      inverted: true
    min_value: 0
    max_value: 100
    resolution: 1
    internal: true
    on_clockwise:
      then:
        - lambda: |-
            // Do nothing if still booting
            if (!id(is_boot_complete))
              return;

            // Ignore encoder rotation
            if (id(main_display).get_active_page() == id(page_graph_duration_restart_confirm)
                || id(main_display).get_active_page() == id(page_is_restarting)
                || id(main_display).get_active_page() == id(page_wifi_ap_mode)
                || id(main_display).get_active_page() == id(page_is_updating))
              return;

            // Needed since we don't sleep on notification page
            // but we do auto dimming, so we need to wake up the display again
            if (id(main_display).get_active_page() == id(page_notification))
            {
              id(wake_display_and_reset_timer).execute();
              return;
            }

            if (id(is_menu_visible))
            {
              id(main_menu).down();
            }
            else if (id(main_display).get_active_page() == id(page_menu_sleep_config))
            {
              // Adjust sleep timeout with adaptive steps
              int32_t current_seconds = id(sleep_timeout_milliseconds) / 1000;
              int32_t step_seconds;
              if (current_seconds < 60)
                step_seconds = 5;
              else if (current_seconds < 600)
                step_seconds = 60;
              else
                step_seconds = 600;

              uint32_t new_val = min(current_seconds + step_seconds, 7200l);
              id(sleep_timeout_milliseconds) = new_val * 1000;
              id(config_auto_sleep).publish_state(new_val);
            }
            else if (id(main_display).get_active_page() == id(page_menu_graph_duration))
            {
              // Adjust graph duration with adaptive steps
              int32_t current = id(graph_duration_minutes);
              int32_t step;
              if (current < 10)
                step = 1;
              else if (current < 60)
                step = 10;
              else
                step = 60;

              id(graph_duration_minutes) = min(current + step, 1440l);
            }
            else if (id(main_display).get_active_page() == id(page_update_available))
            {
              // Select button on update available page
              id(update_available_page_selected_button) = (id(update_available_page_selected_button) + 1) % 2;
            }
            else
            {
              // Brightness adjustment (2% steps)
              int32_t current = id(brightness_control).state;
              id(brightness_control).publish_state(min(current + 2, 100l));

              // Save current page and switch to brightness page
              if (id(main_display).get_active_page() != id(page_brightness_control))
                id(last_saved_page) = const_cast<esphome::display::DisplayPage*>(id(main_display).get_active_page());

              id(main_display).show_page(id(page_brightness_control));
              id(return_to_last_saved_page_with_delay).stop();
              id(return_to_last_saved_page_with_delay).execute();
            }

            id(wake_display_and_reset_timer).execute();

    on_anticlockwise:
      then:
        - lambda: |-
            // Do nothing if still booting
            if (!id(is_boot_complete))
              return;

            // Ignore encoder rotation on restart page or WiFi AP mode page
            if (id(main_display).get_active_page() == id(page_graph_duration_restart_confirm)
                || id(main_display).get_active_page() == id(page_is_restarting)
                || id(main_display).get_active_page() == id(page_wifi_ap_mode)
                || id(main_display).get_active_page() == id(page_is_updating))
              return;

            // Needed since we don't sleep on notification page
            // but we do auto dimming, so we need to wake up the display again
            if (id(main_display).get_active_page() == id(page_notification))
            {
              id(wake_display_and_reset_timer).execute();
              return;
            }

            if (id(is_menu_visible))
            {
              id(main_menu).up();
            }
            else if (id(main_display).get_active_page() == id(page_menu_sleep_config))
            {
              // Adjust sleep timeout with adaptive steps
              int32_t current_seconds = id(sleep_timeout_milliseconds) / 1000;
              int32_t step_seconds;
              if (current_seconds <= 60)
                step_seconds = 5;
              else if (current_seconds <= 600)
                step_seconds = 60;
              else
                step_seconds = 600;

              uint32_t new_val = max(current_seconds - step_seconds, 0l);
              id(sleep_timeout_milliseconds) = new_val * 1000;
              id(config_auto_sleep).publish_state(new_val);
            }
            else if (id(main_display).get_active_page() == id(page_menu_graph_duration))
            {
              // Adjust graph duration with adaptive steps
              int32_t current = id(graph_duration_minutes);
              int32_t step;
              if (current <= 10)
                step = 1;
              else if (current <= 60)
                step = 10;
              else
                step = 60;

              id(graph_duration_minutes) = max(current - step, 1l);
            }
            else if (id(main_display).get_active_page() == id(page_update_available))
            {
              // Select button on update available page
              id(update_available_page_selected_button) = (id(update_available_page_selected_button) + 1) % 2;
            }
            else
            {
              // Brightness adjustment (2% steps)
              int32_t current = id(brightness_control).state;
              id(brightness_control).publish_state(max(current - 2, 0l));

              // Save current page and switch to brightness page
              if (id(main_display).get_active_page() != id(page_brightness_control))
                id(last_saved_page) = const_cast<esphome::display::DisplayPage*>(id(main_display).get_active_page());

              id(main_display).show_page(id(page_brightness_control));
              id(return_to_last_saved_page_with_delay).stop();
              id(return_to_last_saved_page_with_delay).execute();
            }

            id(wake_display_and_reset_timer).execute();

  # --- MQTT System Monitor ---

  # CPU
  - platform: mqtt_subscribe
    name: "CPU Usage"
    id: mqtt_cpu_percent
    topic: "obsidianhub/system_monitor/cpu"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    internal: true
    on_value:
      then:
        - lambda: |-
            id(system_monitor_mqtt_last_update) = millis();

  # RAM
  - platform: mqtt_subscribe
    name: "RAM Percent"
    id: mqtt_ram_percent
    topic: "obsidianhub/system_monitor/ram/percent"
    unit_of_measurement: "%"
    accuracy_decimals: 1
    internal: true
  #- platform: mqtt_subscribe
  #  name: "RAM Used"
  #  id: mqtt_ram_used
  #  topic: "obsidianhub/system_monitor/ram/used"
  #  unit_of_measurement: "GB"
  #  accuracy_decimals: 2
  #  internal: true
  #- platform: mqtt_subscribe
  #  name: "RAM Total"
  #  id: mqtt_ram_total
  #  topic: "obsidianhub/system_monitor/ram/total"
  #  unit_of_measurement: "GB"
  #  accuracy_decimals: 2
  #  internal: true

  # Disk Metrics
  #- platform: mqtt_subscribe
  #  name: "Disk Percent"
  #  id: mqtt_disk_percent
  #  topic: "obsidianhub/system_monitor/disk/percent"
  #  unit_of_measurement: "%"
  #  accuracy_decimals: 1
  #  internal: true
  #- platform: mqtt_subscribe
  #  name: "Disk Used"
  #  id: mqtt_disk_used
  #  topic: "obsidianhub/system_monitor/disk/used"
  #  unit_of_measurement: "GB"
  #  accuracy_decimals: 2
  #  internal: true
  #- platform: mqtt_subscribe
  #  name: "Disk Free"
  #  id: mqtt_disk_free
  #  topic: "obsidianhub/system_monitor/disk/free"
  #  unit_of_measurement: "GB"
  #  accuracy_decimals: 2
  #  internal: true
  #- platform: mqtt_subscribe
  #  name: "Disk Total"
  #  id: mqtt_disk_total
  #  topic: "obsidianhub/system_monitor/disk/total"
  #  unit_of_measurement: "GB"
  #  accuracy_decimals: 2
  #  internal: true

  # Disk I/O Metrics
  - platform: mqtt_subscribe
    name: "Disk Read"
    id: mqtt_disk_read
    topic: "obsidianhub/system_monitor/disk/read"
    unit_of_measurement: "MB"
    accuracy_decimals: 2
    internal: true
  - platform: mqtt_subscribe
    name: "Disk Write"
    id: mqtt_disk_write
    topic: "obsidianhub/system_monitor/disk/write"
    unit_of_measurement: "MB"
    accuracy_decimals: 2
    internal: true

  # Network I/O Metrics
  - platform: mqtt_subscribe
    name: "Network Download"
    id: mqtt_net_recv
    topic: "obsidianhub/system_monitor/net/recv"
    unit_of_measurement: "MB/s"
    accuracy_decimals: 2
    internal: true
  - platform: mqtt_subscribe
    name: "Network Upload"
    id: mqtt_net_sent
    topic: "obsidianhub/system_monitor/net/sent"
    unit_of_measurement: "MB/s"
    accuracy_decimals: 2
    internal: true

  # --- HomeAssistant Brightness Sync ---

  # Sync brightness from Home Assistant on boot/reconnect
  #- platform: homeassistant
  #  id: brightness_sync_boot
  #  entity_id: light.wled_main
  #  attribute: brightness
  #  internal: true
  #  filters:
  #    #- filter_out: nan  # Ignore None/null values
  #    - lambda: |-
  #        // Prevent negative/invalid values
  #        if (std::isnan(x) || x > 255 || x < 0)
  #          return 0;
  #        return x;

###############################################################
# Text Sensors
###############################################################
text_sensor:
  # Uptime
  - platform: uptime
    name: "Uptime"
    id: text_sensor_uptime
    update_interval: 30s
    format:
      separator: " "
      days: "D"
      expand: true

  # Convert numeric AQI to descriptive text
  - platform: template
    name: "Air Quality"
    id: text_sensor_air_quality
    icon: mdi:chemical-weapon
    update_interval: 2s
    lambda: |-
      switch ((uint32_t)(id(sensor_aqi).state))
      {
          case 1: return {"Excellent"};
          case 2: return {"Good"};
          case 3: return {"Moderate"};
          case 4: return {"Poor"};
          case 5: return {"Unhealthy"};
          default: return {"Unknown"};
      }

  # Custom Notification over MQTT (JSON payload)
  - platform: mqtt_subscribe
    name: "Custom Notification"
    id: mqtt_custom_notification
    topic: "obsidianhub/notification"
    internal: true
    on_value:
      then:
        - lambda: |-
            std::string title = "Notification";
            std::string message = "";
            std::string button_text = "OK";
            uint32_t timeout = 0;
            bool show_border = true;

            json::parse_json(x, [&](JsonObject root) -> bool {
              if (root["title"].is<const char*>())
                title = root["title"].as<const char*>();

              if (root["message"].is<const char*>())
                message = root["message"].as<const char*>();

              // Support timeout as int and string
              if (root["timeout"].is<uint32_t>())
                timeout = max(root["timeout"].as<uint32_t>(), 0ul);
              else if (root["timeout"].is<const char*>())
                timeout = max(atoi(root["timeout"].as<const char*>()), 0);

              // Support show_border as bool, string or int (false, "false", 0, "0")
              if (root["show_border"].is<bool>())
              {
                show_border = root["show_border"].as<bool>();
              }
              else if (root["show_border"].is<const char*>())
              {
                std::string border_str = root["show_border"].as<const char*>();
                show_border = (border_str == "true" || border_str == "1");
              }
              else if (root["show_border"].is<int>())
              {
                show_border = root["show_border"].as<int>() != 0;
              }

              // Button text
              if (root["button_text"].is<const char*>())
                button_text = root["button_text"].as<const char*>();

              return true;
            });

            if (message.empty())
            {
              ESP_LOGW("notification", "Notification ignored - empty message");
              return;
            }

            // Show notification if we have a message and are not on certain pages
            if (id(main_display).get_active_page() != id(page_is_updating)
                && id(main_display).get_active_page() != id(page_wifi_ap_mode)
                && id(main_display).get_active_page() != id(page_is_restarting)
                && id(main_display).get_active_page() != id(page_graph_duration_restart_confirm))
            {
              id(show_notification)->execute(title, message, timeout, show_border, button_text);
            }

###############################################################
# Binary Sensors (Physical Buttons)
###############################################################
binary_sensor:
  # Left tactile button
  - platform: gpio
    pin:
      number: GPIO21
      inverted: true
    name: "Left Switch"
    id: button_left
    use_interrupt: true
    filters:
      - delayed_on: 10ms  # Debounce
    on_press:
      then:
        - script.execute: wake_display_and_reset_timer

  # Right tactile button
  - platform: gpio
    pin:
      number: GPIO20
      inverted: true
    name: "Right Switch"
    id: button_right
    use_interrupt: true
    filters:
      - delayed_on: 10ms  # Debounce
    on_press:
      then:
        - script.execute: wake_display_and_reset_timer

  # Rotary encoder push button
  - platform: gpio
    pin:
      number: GPIO6
      inverted: true
    name: "Encoder Switch"
    id: button_encoder
    use_interrupt: true
    filters:
      - delayed_on: 10ms  # Debounce
    # On button down
    on_press:
      then:
        - lambda: |-
            // Do nothing if still booting
            if (!id(is_boot_complete))
              return;

            // Only ignore next short press if display is sleeping
            // Not just fading out into sleep/only LEDs sleeping
            if (id(is_display_sleeping))
              id(ignore_next_encoder_button_press_after_wake_up) = true;

            // Wake immediately when button is pressed down and check for long press
            id(wake_display_and_reset_timer).execute();
            id(check_for_long_press).stop();
            id(check_for_long_press).execute();
    # Short press (button released again)
    on_click:
      - min_length: 2ms
        max_length: 599ms
        then:
          - lambda: |-
              id(check_for_long_press).stop();

              // Do nothing if still booting, on WiFi AP mode page, updating page or restarting page
              if (!id(is_boot_complete)
                  || id(main_display).get_active_page() == id(page_wifi_ap_mode)
                  || id(main_display).get_active_page() == id(page_is_restarting)
                  || id(main_display).get_active_page() == id(page_is_updating))
                return;

              if (id(ignore_next_encoder_button_press_after_wake_up))
              {
                // Ignore this button press (when waking display up from sleep)
                id(ignore_next_encoder_button_press_after_wake_up) = false;
                return;
              }

              // Stop script in case we are on brightness page with automatic return to last saved page
              id(return_to_last_saved_page_with_delay).stop();

              // Handle pages
              if (id(main_display).get_active_page() == id(page_update_available))
              {
                if (id(update_available_page_selected_button) == 0)
                {
                  // Install update now
                  id(component_update_firmware_http).perform(true);
                }
                else
                {
                  // Later button pressed - return to current dashboard, don't install update
                  id(is_menu_detail_visible) = false;
                  id(is_menu_visible) = false;
                  id(return_to_current_dashboard).execute();

                  // Restore LEDs
                  auto call = id(led_status).make_call();
                  call.set_effect("None");
                  call.perform();
                  id(restore_led_states).execute();

                  id(update_available_page_selected_button) = 0;
                }

                return;
              }
              else if (id(main_display).get_active_page() == id(page_graph_duration_restart_confirm))
              {
                // Show "Restarting..." page
                id(main_display).show_page(id(page_is_restarting));

                // Force save preferences to flash immediately
                global_preferences->sync();
                delay(1500);

                id(main_display).clear();
                id(main_display).update();

                App.safe_reboot();

                return;
              }
              else if (id(main_display).get_active_page() == id(page_menu_graph_duration))
              {
                // Leaving graph duration page - show restart confirmation
                id(update_graph_durations).execute();
                id(main_display).show_page(id(page_graph_duration_restart_confirm));

                id(is_menu_detail_visible) = false;
                id(is_menu_visible) = false;

                return;
              }
              else if (id(main_display).get_active_page() == id(page_notification))
              {
                // Dismiss notification
                id(return_to_current_dashboard).execute();
                return;
              }
              else if (id(is_menu_visible))
              {
                id(main_menu).enter();
              }
              else if (id(is_menu_detail_visible))
              {
                id(is_menu_detail_visible) = false;
                id(is_menu_visible) = true;
                id(main_display).show_page(id(page_menu));
              }
              else
              {
                // Cycle through pages
                const uint8_t num_pages = ${num_dashboard_pages if enable_system_monitor_dashboard else num_dashboard_pages - 1};

                id(current_dashboard_page) = (id(current_dashboard_page) + 1) % num_pages;
                id(return_to_current_dashboard).execute();
              }

###############################################################
# Control Buttons
###############################################################
button:
  # Reboot
  - platform: template
    name: "Reboot"
    id: button_restart
    icon: mdi:restart
    entity_category: "config"
    on_press:
      then:
        - lambda: |-
            id(return_to_last_saved_page_with_delay).stop();

            // Show "Restarting..." page
            id(is_menu_detail_visible) = false;
            id(is_menu_visible) = false;

            id(main_display).show_page(id(page_is_restarting));
            id(wake_display_and_reset_timer).execute();

            // Force save preferences to flash immediately
            global_preferences->sync();
            delay(2000);

            id(main_display).clear();
            id(main_display).update();
            App.safe_reboot();

  # Factory Reset
  - platform: template
    name: "Reset To Factory Defaults"
    id: button_reset_to_factory_defaults
    icon: mdi:cog
    entity_category: "config"
    on_press:
      then:
        - lambda: |-
            id(return_to_last_saved_page_with_delay).stop();

            // Show "Restarting..." page
            id(is_menu_detail_visible) = false;
            id(is_menu_visible) = false;

            id(main_display).show_page(id(page_is_restarting));
            id(wake_display_and_reset_timer).execute();

            global_preferences->reset();
            delay(2000);

            id(main_display).clear();
            id(main_display).update();
            App.safe_reboot();

###############################################################
# Configuration Switches
###############################################################
switch:
  # Invert Display
  - platform: template
    name: "Invert Display"
    id: switch_invert_display
    entity_category: "config"
    icon: mdi:theme-light-dark
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    on_turn_on:
      then:
        - script.execute: wake_display_and_reset_timer
        - lambda: |-
            id(main_display).set_invert(true);
    on_turn_off:
      then:
        - script.execute: wake_display_and_reset_timer
        - lambda: |-
            id(main_display).set_invert(false);

  # Auto Dim Display
  - platform: template
    name: "Auto Dim"
    id: switch_auto_dim_display
    entity_category: "config"
    icon: mdi:lightbulb-on-60
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    on_state:
      then:
        - script.execute: wake_display_and_reset_timer

###############################################################
# Dropdown Select
###############################################################
select:
  # Sleep Components
  - platform: template
    name: "Components To Sleep"
    id: select_sleep_components
    entity_category: "config"
    icon: mdi:sleep
    restore_value: true
    optimistic: true
    options:
     - "Both"
     - "Display"
     - "LEDs"
    initial_option: "Both"
    set_action:
      - script.execute: wake_display_and_reset_timer

###############################################################
# Numbers
###############################################################
number:
  # Brightness control - can be read and set from Home Assistant
  - platform: template
    name: "Brightness Control"
    id: brightness_control
    icon: mdi:brightness-percent
    unit_of_measurement: "%"
    min_value: 0
    max_value: 100
    step: 1
    initial_value: 0
    restore_value: true
    optimistic: true
    set_action:
      - lambda: |-
          // Do nothing if still booting or on certain pages
          if (!id(is_boot_complete)
              || id(main_display).get_active_page() == id(page_graph_duration_restart_confirm)
              || id(main_display).get_active_page() == id(page_is_restarting)
              || id(main_display).get_active_page() == id(page_wifi_ap_mode)
              || id(main_display).get_active_page() == id(page_is_updating)
              || id(main_display).get_active_page() == id(page_update_available)
              || id(main_display).get_active_page() == id(page_notification)
              || id(is_menu_visible))
            return;

          // Save current page and switch to brightness page
          if (id(main_display).get_active_page() != id(page_brightness_control))
            id(last_saved_page) = const_cast<esphome::display::DisplayPage*>(id(main_display).get_active_page());

          id(main_display).show_page(id(page_brightness_control));
          id(return_to_last_saved_page_with_delay).stop();
          id(return_to_last_saved_page_with_delay).execute();

          // Wake display and show brightness page
          id(wake_display_and_reset_timer).execute();

  # Display brightness
  - platform: template
    name: "Display Brightness"
    id: config_display_brightness
    entity_category: "config"
    icon: mdi:monitor
    restore_value: true
    optimistic: true
    min_value: 10
    max_value: 100
    initial_value: 100
    step: 10
    unit_of_measurement: "%"
    on_value:
      then:
        - lambda: |-
            id(wake_display_and_reset_timer).execute();
            id(display_brightness) = ((float)x / 100.0f);
            id(main_display).set_contrast(id(display_brightness));

  # Auto sleep
  - platform: template
    name: "Auto Sleep Time"
    id: config_auto_sleep
    entity_category: "config"
    icon: mdi:timer
    restore_value: true
    optimistic: true
    min_value: 0       # 0 = never sleep
    max_value: 7200    # Max 2 hours
    initial_value: 30
    step: 1
    unit_of_measurement: "s"
    mode: box
    on_value:
      then:
        - lambda: |-
            id(wake_display_and_reset_timer).execute();
            id(sleep_timeout_milliseconds) = (uint32_t)(x * 1000);
